/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 10);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/*define(function(){*/
	function ChartsParent(){
	}

	var chartsproto = ChartsParent.prototype;


	chartsproto.init = function(){

		this.extendOpts();

		this.firstCalculate();

		this.drawMain();	

		this.listenWindow();

		this.addListenDynamic();

		this.addListenClick();
	};


	chartsproto.extendOpts = function(){
		throw new Error('子类必须重写 extendOpts');
	};



	chartsproto.drawMain = function(){
		throw new Error('子类必须重写 drawMain');
	};


	// 添加事件监听
	chartsproto.listenWindow = function(){
		var dom = this.dom;
		var c = 10; // 当元素宽度改变超过10时重绘
		var _this = this;

		window.addEventListener('resize', function(){
			if (_this.opts.dom.width !== this.width) {
				_this.drawMain();
				_this.saveOriginal();
			}
			
		})		

	}


	// 绘制标题
	chartsproto.drawTitle = function(){
		var opts = this.opts;
		var ctx = this.ctx;
		var width = this.width;
		var height = this.height;

		this.titleNeedH = 10;



		// 绘制标题


			var title = this.title;
			var font = title.font;
			var fontSize = title.fontSize = font.slice(0, 2); // 将标题的字体大小传出去

			ctx.font = font;
			ctx.fillStyle = title.color;
			ctx.textAlign = "start";

			ctx.beginPath();

			var paddingLR = this.paddingLR;
			var draw ;
			var tLen = ctx.measureText(title.text).width;
			var tLeft ;
			switch(title.position)
			{
			    case 'center':
			    	tLeft = Math.floor((width-tLen)/2) - 5;     // 减5的目的是为了人的视觉差，更感觉居中
			        break;
			    case 'left':
			        tLeft = paddingLR;
			        break;
			    case 'right':
			    	tLeft = Math.floor(width - paddingLR);
			    	ctx.textAlign = "right";
			        break;
			}
			ctx.fillText(title.text, tLeft, fontSize*1.5);  // 内容 起始位置 
			this.titleNeedH = Math.floor(fontSize*2); // 将titleNeedH外传，预留头部的位置

	}


	// 绘制图例信息
	chartsproto.drawCutLine = function(){

		var title = this.title;
		var cutLine = this.cutLine = this.opts.cutLine;
		var ctx = this.ctx;	
		var arr = this.series;
		var width = this.width;
		var height = this.height;



		if (!cutLine) {
			cutLine = this.cutLine = {}
		}
		var pst = cutLine.position ? cutLine.position : 'bottom';  // 图例的位置
		this.cutLine.position = pst;


		/***********  外部目前不可修改  ***********/
		var maxHeightPer = 0.8;
		var boxW = 10;  // 小区块的宽
		var boxH = 6;   // 小区块的高
		var boxMargin  = 3;  // 小区块右的留白
		var space = 10;  // 每个信息间间距
		var minTextW = 60;  // 最小文本宽度 
		var maxTextW = 100;  // 最小文本宽度
		var needLen = this.cutLine.needLen = 1;  // 需要的行数，默认为1
		var fontSize = this.cutLine.fontSize = 12;
		var fontColor = '#000';
		/****************************************/

		ctx.font = fontSize + 'px Arial';

		var len = arr.length;  // 需要绘制的个数
		var canW = width - this.paddingLR*2;  // 可以占据的宽度
		var canH = height - this.titleNeedH;  // 可以占据的高度


		var cutLineNeedH = this.cutLineNeedH = 10;
		var cutLineNeedW = this.cutLineNeedW = (minTextW + boxW + boxMargin) + this.paddingLR;  // 当前预留的宽度为最小宽度+左边距

		if(pst === 'bottom' || pst === 'top'){
			tb.call(this);
		}else if(pst === 'right' || pst === 'left'){
			lr.call(this);
		}

		function tb(){
			var allCxtLength = 0;  // 最终的总文本长度
			var needAllLen = 0;  // 总文本长度+图例小方块宽度边距以及间距
			var drawNum = 0;  // 所需绘制的个数
			var arrLen = arr.length;

			// 将截取文本和截取后的文本长度传入数组，并且获得最终的总文本长度
			for (var i = 0; i < arrLen; i++) {
				var str = arr[i]['name'];
				if (ctx.measureText(str).width > maxTextW) {
					str = arr[i]['cutName'] = cutString(str, maxTextW);
				}else{
					arr[i]['cutName'] = str;
				} 

				var ctxLen = Math.floor(ctx.measureText(str).width);
				arr[i]['ctxLen'] = ctxLen;
				allCxtLength += ctxLen;
				
			}
			

			needAllLen = allCxtLength + arrLen*(boxMargin + boxW) + (arrLen-1)*space;
			drawNum = arrLen;

			// 判断坐标左边预留的是否有位置
			if (typeof this.opts.style === 'undefined') {
				this.opts.style = {}
			}
			var style = this.opts.style;
			if(typeof style.csYTxtLen === 'undefined'){
				style.csYTxtLen = 0;
			}

			// 判断需要绘制几行，最大为两行	
			if(needAllLen > canW - style.csYTxtLen){  // 需要绘制两行
				canW = canW - style.csYTxtLen;
				needLen = this.cutLine.needLen  = 2;
				this.cutLineNeedH = 3*fontSize;  // 设置其预留的高度
				var firstNum = getOneLenNum(0, canW, 1);  // 获取一行可以排几个图例信息,2为定位的高度
				var secondNum = getOneLenNum(firstNum, canW, 2.5);

				this.cutLine.firstNum = firstNum;  // 第一排可放个数
				this.cutLine.secondNum = secondNum;  // 第一排可放个数
				drawNum = firstNum + secondNum;

			}else{
				canW = needAllLen;
				this.cutLineNeedH = 2*fontSize;
				getOneLenNum(0, needAllLen+1, 1);
			}

			var outTop = 0;  // 计算外部的高度
			var outLeft = 0;
			if (needLen === 2) {
				outLeft = Math.floor(this.paddingLR + style.csYTxtLen);
			}else{
				outLeft = Math.floor((width - canW)/2);
			}
			
			if (pst === 'top') {
				outTop = this.titleNeedH;
			}else{

				outTop = height - this.cutLineNeedH;
			}
			this.cutLine.outTop = outTop;
			this.cutLine.outLeft = outLeft;
			setPostionTB(arr, outTop, outLeft);


			// 绘制
			ctx.font = fontSize +'px Arial';
			ctx.textAlign = "start";

			for (var i = 0; i < drawNum; i++) {
				var pstAbsolute = arr[i]['cutLinePst'];

				ctx.beginPath();

				if (arr[i].isShow) {
					ctx.fillStyle= arr[i]['color'][0];
				}else{
					ctx.fillStyle= '#ccc';
				}
								
				ctx.rect(pstAbsolute['boxLeftA'] , pstAbsolute['boxTopA'] , boxW, boxH);
				ctx.fill();
				ctx.beginPath();
				if (arr[i].isShow) {
					ctx.fillStyle = fontColor;
				}else{
					ctx.fillStyle = '#ccc';
				}
				
				ctx.fillText(arr[i]['cutName'], pstAbsolute['textLeftA'], pstAbsolute['textTopA']);
		
			}	

		}


		function lr(){

			var sTop = this.titleNeedH; // 默认绘制的起始位置

			var thisH = len*(fontSize + boxMargin*2) - boxMargin*2; // 所需的总共高度


			// 如果所需高度大于可放置内容的高度
			var showLen = len; // 需要绘制的长度
			if (thisH > canH) {
				showLen = Math.floor(canH/(fontSize + boxMargin*2));
				var showLenL = showLen*(fontSize + boxMargin*2) + fontSize; // 再加一排的高度 
				if (showLenL <= canH) {
					showLen ++;
				}
			}else{
				sTop = Math.floor((height - thisH)/2) + this.titleNeedH;
			}


			var picW = minTextW;
			if(width*0.1 > cutLineNeedW){
				cutLineNeedW = this.cutLineNeedW = width*0.2;
				picW = cutLineNeedW - this.paddingLR - boxMargin - boxW;

			}


			// 如果文本过长，截取内容
			for (var i = 0; i < len; i++) {

				var txt = arr[i]['name'];
				var thisLen = Math.floor(ctx.measureText(txt).width);

				if (thisLen > picW) {

					arr[i]['cutName'] = cutString(txt, picW)
					change = 1;
				}else{
					arr[i]['cutName'] = txt;
				}

				arr[i]['ctxLen'] = 	Math.floor(ctx.measureText(arr[i]['cutName']).width);
			}


			var sLeft = this.paddingLR;
			if (pst === 'right') {
				sLeft = Math.floor(width - cutLineNeedW);
			}

			// 将起始绘制的位置传出
			this.cutLine.outLeft = sLeft;
			this.cutLine.outTop = sTop;
			this.cutLine.W = picW + boxMargin + boxW;  // 总体图例的宽度
			this.cutLine.showLen = showLen;


			setPostionLF(arr, sTop, sLeft);
			
			// 绘制
			ctx.font = fontSize + 'px Arial';
			for (var i = 0; i < len; i++) {

				var pstAbsolute = arr[i]['cutLinePst'];

				ctx.beginPath();

				if (arr[i].isShow) {
					ctx.fillStyle= arr[i]['color'][0];
				}else{
					ctx.fillStyle= '#ccc';
				}


				ctx.rect(pstAbsolute['boxLeftA'] , pstAbsolute['boxTopA'] , boxW, boxH);
				ctx.fill();
				ctx.beginPath();

				if (arr[i].isShow) {
					ctx.fillStyle = fontColor;
				}else{
					ctx.fillStyle= '#ccc';
				}

				ctx.fillText(arr[i]['cutName'], pstAbsolute['textLeftA'], pstAbsolute['textTopA'])
				


			}
		}

		/**
		 * 返回一行可以排几个图例信息，并将每个的位置信息写入数组中的对象
		 * @param  {number} start 起始计算的位置
		 * @param  {number} width 可以放置的长度
		 * @return {number}       可以放置的个数
		 */
		function getOneLenNum(start, width, n){
			var num = 0;  // 返回的可以放置的个数
			var lenSum = 0;

			for (var i = start, arrLen = arr.length; i < arrLen; i++) {

				var pst = arr[i]['cutLinePst'] = {};
				pst['textTop'] = fontSize*n;
				pst['boxTop'] = fontSize*(n - 0.5) - boxH/2 + 1;
				pst['boxLeft'] = lenSum;
				pst['textLeft'] = boxW + boxMargin + lenSum; 

				lenSum += arr[i]['ctxLen'] + boxW + boxMargin + space;

				if (lenSum > width) {
					num = i - start;
					break;				
				}else{
					num = arrLen - start;				
				}
				
			}

			return num;
		}

		/**
		 * 设置在canvas画布上的绝对定位
		 * @param {Arrage} arr [description]
		 * @param {Number} top    开始绘制图例区域的距canvas画布top的位置
		 * @param {Number} left   开始绘制图例区域的距canvas画布left的位置
		 */
		function setPostionTB(arr, top, left){
			for (var i = 0, arrLen = arr.length; i < arrLen; i++) {

				var pst = arr[i]['cutLinePst'];
				pst['textTopA'] = pst['textTop'] + top;
				pst['boxTopA'] = pst['boxTop'] + top;
				pst['boxLeftA'] = pst['boxLeft'] + left;
				pst['textLeftA'] = pst['textLeft'] + left; 
				
			}
		}

		function setPostionLF(arr, top, left){
			for (var i = 0, arrLen = arr.length; i < arrLen; i++) {

				var pst = arr[i]['cutLinePst'] = {};
				pst['textTopA'] = fontSize*i + boxMargin*2*(i-1) + top; // 两个文本间距为2个boxMargin
				pst['boxTopA'] = fontSize*i + boxMargin*2*(i-1) - fontSize/2 - boxH/2 + top + 2;
				pst['boxLeftA'] = left;
				pst['textLeftA'] = boxW + boxMargin + left; 
				
			}
		}
		function getOneTextMaxW(len){
			var num = Math.floor((canW - space*(len - 1))/len)-boxW-boxMargin;  // 每个文本最大距离
			return num;
		}  

		// 	判断数据是否需要截取,返回截取后的数据
		function cutString(str, maxL){
			
			var i = 1;
			var w = ctx.measureText(str.slice(0, 1)).width;
			while(w < maxL){

				var newStr = str.slice(0, i);
				i++;
				w = ctx.measureText(newStr).width;
			}

			rStr = str.slice(0, i-2) + '..';

			return rStr;
		}

	}



	// 确定主体的绘制区域
	chartsproto.confirmContentRegion = function(){

		// 	确定需要给坐标预留的空间
		var cutLine = this.cutLine;
		var title = this.title;
		var picPst = cutLine.position;
		var width = this.width;
		var height = this.height;

		var titleNeedH = this.titleNeedH;
		var cutLineNeedH = this.cutLineNeedH;
		var cutLineNeedW = this.cutLineNeedW;
		var paddingLR = this.paddingLR;

		var content = this.content = {};
	 	content.conTop = titleNeedH;
	 	content.conHeight = titleNeedH;
		if (picPst === 'left' || picPst === 'right') {
			content.conHeight = height - titleNeedH;
			content.conWidth = width - paddingLR*2 - cutLineNeedW;

			if (picPst === 'left') {			
				content.conLeft = paddingLR + cutLineNeedW ;			
			}else{
				content.conLeft = paddingLR;
			}


		}else if(picPst === 'top' || picPst === 'bottom'){
			
			content.conHeight = height - titleNeedH - cutLineNeedH;
			content.conWidth = width - paddingLR*2;
			content.conLeft = paddingLR;

			if (picPst === 'top') {
				content.conTop = titleNeedH + cutLineNeedH;
			}else{
				content.conTop = titleNeedH;
			}
			
		}


	}


	chartsproto.chartInit = function(){


		this.drawTitle();

		this.drawCutLine();

		this.confirmContentRegion();

		this.drawContent();

	}


	// 添加监听鼠标移动的特效动效
	chartsproto.addListenDynamic = function(){


		var _this = this;
		var dom = this.opts.dom;
		var width = this.width;
		var height = this.height;


		var isShowDots = false;  // 是否显示了小圆点


		this.saveOriginal();

		window.addEventListener('mousemove', function(e){
	
			var gbc = dom.getBoundingClientRect();
			var top = gbc.top;
			var left = gbc.left;
			
			var x = e.clientX;
			var y = e.clientY;
			
			// 判断是否在canvas的区域内
			if (x > left && x < left + width && y > top && y < top + height) {
	
				// 鼠标在canvas上的相对坐标
				var cx = x - left;
				var cy = y - top;

				var pst = _this.cutLine.position;
				var series = _this.series;


				
				// 区域分为两部分判断,图例左右显示
				if ( pst === 'left' || pst === 'right') {


					if (cx > _this.cutLine.outLeft && cx < _this.cutLine.outLeft + _this.cutLine.W) {

						analyzingConditionsAreaY(_this.cutLine.showLen, _this.cutLine.fontSize);




					// 进入中间主体区域
					}else if (cx > _this.content.conLeft && cx < _this.content.conLeft + _this.content.conWidth){
						


						if (isShowDots) {
							// console.log('第一次清除');
							_this.showOriginal();
							isShowDots = false;
							isMovein = false;
							_this.opts.dom.style.cursor = 'default';


						}
						_this.moveToContent(cx, cy);
						
					}else {

						if (isShowDots) {
							// console.log('第一次清除');
							_this.showOriginal();
							isShowDots = false;
							isMovein = false;
							_this.opts.dom.style.cursor = 'default';
						}
					}



				// 图例上下显示
				}else {
					if (cy > _this.cutLine.outTop && cy < _this.cutLine.outTop + _this.cutLineNeedH) {


						
						// 图例只有一排
						if (_this.cutLine.needLen === 1) {
							analyzingConditionsAreaX(0, _this.series.length);
						// 图例有两排
						}else if (_this.cutLine.needLen === 2) {
							// 第一排
							if (cy > _this.cutLine.outTop && cy < _this.cutLine.outTop + _this.cutLineNeedH*0.5) {
								analyzingConditionsAreaX(0, _this.cutLine.firstNum)

							// 第二排
							}else if(cy > _this.cutLine.outTop + _this.cutLineNeedH*0.5 && cy < _this.cutLine.outTop + _this.cutLineNeedH){
								analyzingConditionsAreaX(_this.cutLine.firstNum, _this.cutLine.firstNum + _this.cutLine.secondNum)

							}
						}

					}else if (cy > _this.content.conTop && cy < _this.content.conTop + _this.content.conHeight) {
						
						if (isShowDots) {
							// console.log('第一次清除');
							_this.showOriginal();
							isShowDots = false;
							isMovein = false;
							_this.opts.dom.style.cursor = 'default';
						}
						
						_this.moveToContent(cx, cy);
						
					}else{
						if (isShowDots) {
							// onsole.log('第一次清除');
							_this.showOriginal();
							isShowDots = false;
							isMovein = false;
							_this.opts.dom.style.cursor = 'default';

						}

					}

				}


				/**
				 * 遍历判断是否在区域内
				 * @param {Number} start 起始值
				 * @param {Number} len   当前条件下的一排的个数
				 */
				function analyzingConditionsAreaX(start, len){
					var moveI ;
					var isMovein = false;  // 是否移入了图标
					for (var i = start; i < len; i++) {
						if ( cx > series[i].cutLinePst.boxLeftA && cx < series[i].cutLinePst.textLeftA + series[i].ctxLen) {									
							isMovein = true;
							moveI = i;
						}
					}
					if (isMovein) {
						
						if (!series[moveI].isShow) {return}

						if (isShowDots) { return;}
						
						_this.drawMoveChange(series[moveI]);
						isShowDots = true;
						_this.opts.dom.style.cursor = 'pointer';
					}else{
												
						if (!isShowDots) {return;}						
						isShowDots = false;
						isMovein = false;
						_this.showOriginal();
						
						_this.opts.dom.style.cursor = 'default';
					}
				}

				/**
				 * @param {Number} len      当前条件下的竖排的个数
				 * @param {Number} fontSize 图例的字体大小
				 */
				function analyzingConditionsAreaY(len, fontSize){
					var moveI ;
					var isMovein = false;  // 是否移入了图标
					for (var i = 0; i < len; i++) {
						if ( cy > series[i].cutLinePst.textTopA -  fontSize&& cy < series[i].cutLinePst.textTopA ) {	
							if (cx > series[i].cutLinePst.boxLeftA && cx < series[i].cutLinePst.textLeftA +series[i].ctxLen) {
								isMovein = true;
								moveI = i;
							}								
						}
					}
					if (isMovein) {
						if (!series[moveI].isShow) {return}  // 图标显示为灰色的就不画该圆点了

						if (isShowDots) { return;}
						
						_this.drawMoveChange(series[moveI]);
						isShowDots = true;
						_this.opts.dom.style.cursor = 'pointer';
					}else{
							

						if (_this.isShowOriginal === false) {
							_this.showOriginal();
						}

						if (!isShowDots) {return;}
												
						isShowDots = false;
						isMovein = false;
						
						_this.opts.dom.style.cursor = 'default';



					}
				}

			}
			
		})

	}


	// 添加图例的点击事件
	chartsproto.addListenClick = function(){
		var dom = this.opts.dom;
		var _this = this;
		var series = this.series;



		dom.addEventListener('click', function(e){

			var gbc = dom.getBoundingClientRect();
			var top = gbc.top;
			var left = gbc.left;
			
			var x = e.clientX;
			var y = e.clientY;

			var cx = x - left;
			var cy = y - top;


			var pst = _this.cutLine.position;
			var series = _this.series;
			


			// 区域分为两部分判断,图例左右显示
			if ( pst === 'left' || pst === 'right') {

				if (cx > _this.cutLine.outLeft && cx < _this.cutLine.outLeft + _this.cutLine.W) {

					showAndHideY(_this.cutLine.showLen, _this.cutLine.fontSize);
				
				}


			// 图例上下显示
			}else {
				if (cy > _this.cutLine.outTop && cy < _this.cutLine.outTop + _this.cutLineNeedH) {


					
					// 图例只有一排
					if (_this.cutLine.needLen === 1) {
						showAndHideX(0, _this.series.length);
					// 图例有两排
					}else if (_this.cutLine.needLen === 2) {
						// 第一排
						if (cy > _this.cutLine.outTop && cy < _this.cutLine.outTop + _this.cutLineNeedH*0.5) {
							showAndHideX(0, _this.cutLine.firstNum)

						// 第二排
						}else if(cy > _this.cutLine.outTop + _this.cutLineNeedH*0.5 && cy < _this.cutLine.outTop + _this.cutLineNeedH){
							showAndHideX(_this.cutLine.firstNum, _this.cutLine.firstNum + _this.cutLine.secondNum)

						}
					}

				}
			}


 
			/**
			 * 确定点击的是哪个图例，当图例为横排时
			 * @param {Number} start 起始值
			 * @param {Number} len   当前条件下的一排的个数
			 */
			function showAndHideX(start, len){
				var thisI ;
				var isMovein = false;  // 是否移入了图标

				for (var i = start; i < len; i++) {
					
					if ( cx > series[i].cutLinePst.boxLeftA && cx < series[i].cutLinePst.textLeftA + series[i].ctxLen) {									
						isMovein = true;
						thisI = i;
						
						
					}
				}


				if (isMovein === true) {
					_this.series[thisI].isShow = !series[thisI].isShow;
					_this.clickFlow();
				}

				

			}


			/** 
			 * 确定点击的是哪个图例，当图例为竖排时
			 * @param {Number} len      当前条件下的竖排的个数
			 * @param {Number} fontSize 图例的字体大小
			 */
			function showAndHideY(len, fontSize){
				var thisI ;
				var isMovein = false;  // 是否移入了图标

				for (var i = 0; i < len; i++) {
					if ( cy > series[i].cutLinePst.textTopA -  fontSize&& cy < series[i].cutLinePst.textTopA ) {	
						if (cx > series[i].cutLinePst.boxLeftA && cx < series[i].cutLinePst.textLeftA +series[i].ctxLen) {
							isMovein = true;
							moveI = i;
						}								
					}
				}


				if (isMovein) {
					_this.series[moveI].isShow = !series[moveI].isShow;

					_this.clickFlow();
				}




			}



		})





		// 返回与原数组长度相同的全为0的数组
		function changeZero(data){
			var arr = [];

			for (var i = 0, len = data.length; i < len; i++) {
				arr.push(0);
			}
			return arr;

		}
	}



	// 初始化series[i]全部为isShow = true
	chartsproto.initializationIsShowData = function(series){

		for (var i = 0, len = series.length; i < len; i++) {
			series[i].isShow = true;

		}
	}



	// 将之前绘制好的图片重新绘制到画板上 
	chartsproto.showOriginal = function(){
		
		this.ctx.clearRect( 0 , 0 , this.width , this.height );
		this.ctx.drawImage(this.newCanvas, 0, 0);		

	}	


	// 保存原始绘制好的图片
	chartsproto.saveOriginal = function(){
		if(!this.newCanvas){
			this.newCanvas = document.createElement('CANVAS'); 
			this.newCtx = this.newCanvas.getContext('2d');

		}
		this.newCanvas.width = this.width;
		this.newCanvas.height = this.height;
		
		var dom = this.opts.dom;

		this.newCtx.drawImage( dom, 0, 0 )

	}


	// 备份data
	chartsproto.dataBackUp = function(){
		var series = this.series;
		for (var i = 0, len = series.length; i < len; i++) {

			series[i].dataBackUp = JSON.parse(JSON.stringify(series[i].data));
			series[i].isShow = true;

		}
	}


	chartsproto.bindColor = function(series){
		var colors = ChartsParent.DEFAULTS.colors;
		while (colors.length < series.length) {
			var makeColor = chartsproto.publicFn.makeColor;
			colors.push(makeColor());
		}
		// 颜色数组不够用
		for(var i = 0, len = series.length; i < len; i++){
			if(!series[i]['color']){
				series[i]['color'] = colors[i];
			}
		}

	}



	chartsproto.publicFn = {
		// 生成随机颜色，返回的数组，数组中有两个颜色值
		makeColor: function(){
			var arr = [];
			var a = Math.floor(Math.random()*256);
			var b = Math.floor(Math.random()*256);
			var c = Math.floor(Math.random()*256);
			var color1 = '#'+ fill2(a.toString(16))+fill2(b.toString(16))+fill2(c.toString(16));
			arr.push(color1)
			var color2 = 'rgba('+a+', '+b+', '+c+', .5)';
			arr.push(color2);

			function fill2(str){
				if (str.length === 1) {
					str = '0'+str;
				}

				return str;
			}
			
			return arr;
		}


	}



	ChartsParent.DEFAULTS = {
		colors: [  // 预定义的颜色信息
			['#35A5ED', 'rgba(53, 165, 237, .5)'], 
			['#D7BB6A', 'rgba(221, 192, 93, .5)'], 
			['#4EC56D', 'rgba(86, 180, 118, .5)'], 
			['#B293E3', 'rgba(193, 157, 235, .5)'],
			['#14446A', 'rgba(20, 60,106, .5)'],
			['#D51a21', 'rgba(213, 26, 33, .5)']
		]


	};




/*	return ChartsParent;
})*/


module.exports = ChartsParent;




/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {




var ChartsParent = __webpack_require__(0);


/*
define(['chartsParent'], function(ChartsParent){
*/
	function ColumnChartsParent() {
		
	}

	var proto = ColumnChartsParent.prototype = new ChartsParent;



	// 进行第一次计算
	proto.firstCalculate = function(){
		this.paddingLR = 20 ;  // 设定左右留白区域
		this.isShowOriginal = true;  // 当前是否为初始图形

		var series = this.series;

		// 初始化series[i]全部为isShow = true
		this.initializationIsShowData(series);

		// 备份series中data
		this.dataBackUp();

		this.bindColor(series);


	}


	proto.drawContent = function(){
		
		this.drawCS();
		this.drawGraph();

	}


/*	proto.countBl = function(){
		var csYOneLen = this.opts.style.csYOneLen || 0;  // 纵坐标每个间距的值，由用户控制

		var arr = this.series;

		var maxNum = this.maxNum = this.publicFn.getMaxNum(arr);  // 数据中的最大值
		var minNum = this.minNum = this.publicFn.getMinNum(arr);


		var yCopies = this.cs.yCopies = 3; // 设置默认将y轴分为3分

		// 计算y轴刻度最小的值直接从0开始算
		var csYMin = Math.floor(minNum*0.8);

		var n2 = csYMin.toString().length;
		if (n2 > 1) {
			var n3 = Math.floor(csYMin/10);
			csYMin = this.cs.csYMin = parseInt(n3.toString() + '0')
		}else{
			this.cs.csYMin = csYMin;
		} 

		var diff = Math.floor(maxNum/0.9 - csYMin); // 差值
		if (csYOneLen) {
			yCopies = Math.ceil(diff/csYOneLen); // 把展示的数据等分为几份
		}else{                              // 将数据的
			var n5 = Math.ceil(diff/yCopies).toString();
			if (parseInt(n5) > 5) {
				n5 = n5.slice(0, n5.length - 1) + '0';
				csYOneLen = parseInt(n5)  + 10;
			}else{
				csYOneLen = parseInt(n5)  + 5;
			}
		}
		
		var diff = yCopies*csYOneLen;  // 最终的跨度
		
		this.bl = this.cs.csHeight/diff;  // 比例
		this.cs.csYOneLen = csYOneLen;
	}*/


/*	// 计算相关的比例,不从0开始算
	proto.countBl = function(){
		
		var csYOneLen = this.opts.style.csYOneLen || 1;  // 纵坐标每个间距的值，由用户控制

		var arr = this.series;

		var maxNum = this.maxNum = this.publicFn.getMaxNum(arr);  // 数据中的最大值
		var minNum = this.minNum = this.publicFn.getMinNum(arr);

		var csYMin = minNum*0.8; 

		var n4 = csYMin.toString().length;
		
		if (n2 > 1) {
			var n3 = Math.floor(csYMin/10);
			csYMin = this.cs.csYMin = parseInt(n3.toString() + '0')
		}else{
			this.cs.csYMin = csYMin;
		}
		var yCopies = 0;  // 设置默认将y轴分为0份

		// 计算y轴刻度最小的值
		this.cs.csYMin = csYMin; 

		var n2 = csYMin.toString().length;
		
		if (n2 > 1) {
			var n3 = Math.floor(csYMin/10);
			csYMin = this.cs.csYMin = parseInt(n3.toString() + '0')
		}else{
			this.cs.csYMin = csYMin;
		}

		var diff = Math.floor(maxNum/0.9 - csYMin);  // 差值

		if (diff < 5) {

			diff = maxNum/0.9 - csYMin;
			var n1 = diff/5;
			var n2 = n1.toString();

			var i = 0;
			var maxI = 0;
			while(i >= 0){
				if (n2.charAt(2+i) !== '0' ) {
					break;
				}

				i++;
			}
			var divisor = 1;
			while(i >= 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			var n3 = n1*divisor;
			if (n3 < 1.4) {
				csYOneLen = 1/divisor;
			}else if(n3 < 2.5){
				csYOneLen = 2/divisor;
			}else if(n3 < 7.5){
				csYOneLen = 5/divisor;
			}else{
				csYOneLen = 10/divisor;
			}


		}else{

			var n1 = Math.ceil(diff/5);  // 将差值除以5，取整
			var n2 = n1.toString().length;  // 取得n1整数位的长度

			var i = n2 -1;
			var divisor = 1;
			while(i > 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			if (divisor === 1) {
				diff +=1;  // 当数值过小时，扩大差值
			}
				var n3 = n1/divisor;
				if (n3 < 1.4) {
					csYOneLen = 1*divisor;
				}else if(n3 < 2.5){
					csYOneLen = 2*divisor;
				}else if(n3 < 7.5){
					csYOneLen = 5*divisor;
				}else{
					csYOneLen = 10*divisor;
				}
			
		}

		yCopies = Math.ceil(diff/csYOneLen);

		
		var diff = yCopies*csYOneLen;  // 最终的跨度


		this.cs.yCopies = yCopies; 
		this.bl = this.cs.csHeight/diff;  // 比例
		this.cs.csYOneLen = csYOneLen;

		setYAxis.call(this);
		function setYAxis(){
			var yAxis = this.yAxis = []; 

			for(var j = 0; j <= yCopies; j++ ){

				var y = csYMin + csYOneLen*(yCopies*1000000-j*1000000)/1000000;	

				yAxis.push(y);			
			}

			console.log(yAxis);

			
		}

	}*/

	// 计算相关的比例
	proto.countBl = function(){
		
		var csYOneLen = this.opts.style.csYOneLen || 1;  // 纵坐标每个间距的值，由用户控制

		var arr = this.series;

		var maxNum = this.maxNum = this.publicFn.getMaxNum(arr);  // 数据中的最大值



		var yCopies = 0;  // 设置默认将y轴分为3分

		// 计算y轴刻度最小的值直接从0开始算
		var csYMin = this.cs.csYMin = 0; 

		var diff = Math.floor(maxNum/0.9 - csYMin);  // 差值

		if (diff < 5) {

			diff = maxNum/0.9 - csYMin;
			var n1 = diff/5;
			var n2 = n1.toString();

			var i = 0;
			var maxI = 0;
			while(i >= 0){
				if (n2.charAt(2+i) !== '0' ) {
					break;
				}

				i++;
			}
			var divisor = 1;
			while(i >= 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			var n3 = n1*divisor;
			if (n3 < 1.4) {
				csYOneLen = 1/divisor;
			}else if(n3 < 2.5){
				csYOneLen = 2/divisor;
			}else if(n3 < 7.5){
				csYOneLen = 5/divisor;
			}else{
				csYOneLen = 10/divisor;
			}


		}else{

			var n1 = Math.ceil(diff/5);  // 将差值除以5，取整
			var n2 = n1.toString().length;  // 取得n1整数位的长度

			var i = n2 -1;
			var divisor = 1;
			while(i > 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
/*			if (divisor === 1) {
				diff +=1;  // 当数值过小时，扩大差值
			}*/
				var n3 = n1/divisor;
				if (n3 < 1.4) {
					csYOneLen = 1*divisor;
				}else if(n3 < 2.5){
					csYOneLen = 2*divisor;
				}else if(n3 < 7.5){
					csYOneLen = 5*divisor;
				}else{
					csYOneLen = 10*divisor;
				}
			
		}

		yCopies = Math.ceil(diff/csYOneLen);

		
		var diff = yCopies*csYOneLen;  // 最终的跨度


		this.cs.yCopies = yCopies; 
		this.bl = this.cs.csHeight/diff;  // 比例
		this.cs.csYOneLen = csYOneLen;

		setYAxis.call(this);
		function setYAxis(){
			var yAxis = this.yAxis = []; 

			for(var j = 0; j <= yCopies; j++ ){

				var y = csYMin + csYOneLen*(yCopies*1000000-j*1000000)/1000000;	

				yAxis.push(y);			
			}

			
		}

	}




	// 绘制绘制横纵坐标
	proto.drawCS = function(){
		var opts = this.opts;
		var ctx = this.ctx;
		var series = this.series;


		var style = this.opts.style;

		this.cs = {};
		var csLeft = this.cs.csLeft = this.content.conLeft + this.opts.style.csYTxtLen;
		var csTop = this.cs.csTop = this.content.conTop + 10;
		var csWidth = this.cs.csWidth = this.content.conWidth - this.opts.style.csYTxtLen;
		var csHeight = this.cs.csHeight = this.content.conHeight - this.opts.style.csXTxtLen - 10;

		var csXLen = opts.xAxis.length ;  // 横坐标需要绘制多少个值,根据数组长度决定




		var csXOneLen = this.cs.csXOneLen = csWidth/csXLen;   // 每一个横坐标的间距

		var xAxis = this.xAxis;
		var series = this.series;

		this.countBl();


		// 横坐标横线绘制
		ctx.beginPath();

		ctx.strokeStyle = style.csXLineColor;
		ctx.lineWidth = style.csXlineWidth;  // 线条宽度

		ctx.moveTo(csLeft , csTop + csHeight);  // 起始点，移动画笔到(0, 0)
		ctx.lineTo(csLeft + csWidth,  csTop + csHeight);  
		ctx.stroke();


		// 判断是否绘制横坐标底部参数
		if(xAxis && this.showXAxis){

			ctx.fillStyle = style.csXfontColor;
			ctx.textAlign = "center";
			var bt = csTop + csHeight;  // 横坐标小短横起始纵位置
			var bb = csTop + csHeight + style.csXEveLen;  // 横坐标小短横结束纵位置 
			var ft = bb + style.csXfontTop;  // 横坐标字体的纵位置

			for(var i = 0; i < csXLen + 1; i++ ){
				ctx.moveTo(csLeft + csXOneLen*i, bt);  
				ctx.lineTo(csLeft + csXOneLen*i,  bb);

				ctx.font = style.csXfont;  // 字号 字体

				if (i == csXLen) { continue;}

				ctx.fillText(xAxis[i], csLeft + csXOneLen*i + csXOneLen/2, ft);  // 内容 起始位置 
				
			}

			ctx.stroke();
		}



		var bl = this.bl;
		var csYOneLen = this.cs.csYOneLen;
		var yCopies = this.cs.yCopies;
		var csYMin = this.cs.csYMin;
		var yAxis = this.yAxis;


		csYOneLenCanvas = bl*csYOneLen; // 跨度比例转换为canvas宽度


		// 绘制纵坐标
		ctx.strokeStyle = style.csYLineColor;
		ctx.fillStyle = style.csYfontColor;
		ctx.lineWidth = style.csYlineWidth;
		ctx.textAlign = "right";

		for(var j = 0; j <= yCopies; j++ ){

			ctx.moveTo(csLeft, csTop + csYOneLenCanvas*j);  
			ctx.lineTo( csLeft + csWidth,  csTop + csYOneLenCanvas*j);

			ctx.font = style.csYfont;  // 字号 字体
			ctx.fillText(yAxis[j], csLeft + style.csYfontLeft, csTop + csYOneLenCanvas*j + style.csYfontTop );  // 内容 起始位置 
			
		}
		ctx.stroke();

		


		// 根据数值、比例、坐标系top值、坐标系高度 ，返回所需的在canvas顶部值和高度值
		function toCSNum(data, bl, t, h, min){

			return t + (h - (data-min)*bl);
			
		}

	}


	proto.drawMain = function(){

		var dom = this.opts.dom;


		/*
		var width = this.width = dom.width ;  // canvas宽
		var height = this.height = dom.height;  // canvas高
		*/


			
		var width = this.width = dom.width = dom.offsetWidth ;  // canvas宽
		var height = this.height = dom.height = dom.offsetHeight;  // canvas高


		this.ctx.clearRect( 0, 0, width, height);


		this.chartInit();

	}




	// 更新数据进行重绘
	proto.reflow = function(opts){

		this.series = opts.series || this.series;
		this.xAxis = opts.xAxis || this.xAxis;

		this.drawMain();


		return this;

	}




	// 鼠标移动到主体区域时,绘制虚线、竖线、相关信息
	proto.moveToContent = function(cx, cy){
		
	}


	// 移动到特定的图例时，特定的颜色加深
	proto.drawMoveChange = function(data){
		var ctx = this.ctx;
		this.showOriginal();
		ctx.beginPath();
		ctx.fillStyle = 'rgba(0, 0, 0, .1)';

		var pst = data.columnPst;
		
		for (var j = 0; j < pst.length; j++) {

			ctx.fillRect(pst[j][0], pst[j][1], pst[j][2], pst[j][3]);  
		}

	}



	proto.publicFn = {

		// data为三维数组，获得所有数据中的最大值
		getMaxNum: function (data){
			
			var max = 0;
			for(var i = 0, len = data.length; i < len; i++){
				for(var j = 0, lenj = data[i]['data'].length; j < lenj; j++){

					if (data[i]['data'][j] > max) {
						max = data[i]['data'][j];
					}
				}
			}

			return max;
		},


		// data为三维数组，获得所有数据中的最大值
		getMinNum: function (data){
			var min = 0;
			for(var i = 0, len = data.length; i < len; i++){

				if (data[i].isShow === false) {continue;}
				for(var j = 0, lenj = data[i]['data'].length; j < lenj; j++){
					if(i === 0 && j === 0){
						min = data[i]['data'][j];
					}

					if (data[i]['data'][j] < min) {
						min = data[i]['data'][j];
					}
				}
			}

			return min;
		},

		//  a为默认参数对象，b为传递进来的参数对象
		extendObj: function (a, b){  
			var str = JSON.stringify(a);
			var newobj = JSON.parse(str)
			for(key in b){
				if(newobj.hasOwnProperty(key)){
					newobj[key] = b[key];
				}else{
					newobj[key] = b[key];
					console.log('传入的参数'+key+'原本没有！');
				}
			}
			return newobj;
		},

		// 生成随机颜色，返回的数组，数组中有两个颜色值
		makeColor: function(){
			var arr = [];
			var a = Math.floor(Math.random()*256);
			var b = Math.floor(Math.random()*256);
			var c = Math.floor(Math.random()*256);
			var color1 = '#'+a.toString(16)+b.toString(16)+c.toString(16);
			arr.push(color1)
			var color2 = 'rgba('+a+', '+b+', '+c+', .5)';
			arr.push(color2);
			return arr;
		},


		// 将data恢复为原始数据
		restoreData: function(series){
			for (var i = 0, len = series.length; i < len ; i++) {
				if (series[i].isShow === false) {
					for (var j = 0, len2 = series[i]['data'].length; j < len2; j++) {
						series[i]['data'][j] = 0;
						
					}
				}else{
					series[i].data = JSON.parse(JSON.stringify(series[i].dataBackUp));
				}
				
			}
		},

		// 数据累加,不改变原数组
		spData2: function(series){
			var cloneData = JSON.parse(JSON.stringify(series));  // 克隆一个对象 
			var len = cloneData.length;
			var len2 = cloneData[0].data.length;  // 应保证 每一行的数据长度相同，这里默认为数据格式正确

			
			for (var i = 0, len = series.length - 1; i < len; i++) {

				for (var j = 0; j < len2; j++) {

					cloneData[i+1].data[j] = cloneData[i].data[j] + cloneData[i+1].data[j];
				} 

			}
			return cloneData;
		}



	}




	// 初始化的参数变量
	ColumnChartsParent.DEFAULTS = {
		style: {
			csYTxtLen: 30,  // 设置y轴的数据预留宽度
			csXTxtLen: 40,

			csXLineColor :'#000',  // 坐标轴X的颜色
			csXlineWidth: 1,  // 坐标轴X线条的宽度
			csXEveLen: 5,  // 横坐标小短横的长度
			csXfont: "10px Arial",  // 横坐标参数的 字号 字体
			csXfontColor: "#000",  // 横坐标参数的颜色
			csXfontTop: 15,  // 横坐标参数距小短横的上位置

			csYLineColor: '#aaa',  // 坐标轴Y的颜色
			csYlineWidth: .2,  // 坐标轴Y线条的宽度
			csYfont: "12px Arial",  // 纵坐标参数的 字号 字体
			csYfontColor: "#000",  // 纵坐标参数的颜色
			csYfontLeft: -10,  // 纵坐标参数距当前长横的左位置
			csYfontTop: 5  // 纵坐标参数距当前长横的上位置
		}
		,
		title: { //图表绘制的区域
			text: '柱状图表',
			color: '#000',
			font: '16px Arial',
			position: 'center',
			isShow: true
		},
	 /*	colorInfo: {
			font: '12px Arial',
			fontColor: '#000',
			boxWidth: 20,
			boxHeight: 20
		},*/
		

	}

	// 参数填充
	proto.extendOpts = function(){
		var opts = this.opts;
		var dom = opts.dom;
		this.xAxis = JSON.parse(JSON.stringify(opts.xAxis));
		this.series =JSON.parse(JSON.stringify(opts.series));


		this.showXAxis = true;
		if(opts.showXAxis != 'undefind'){
			
			this.showXAxis = opts.showXAxis;
		}


		// 坐标系样式信息
		if (!opts.style) {
			this.opts.style = {};
		}
		this.opts.style = this.publicFn.extendObj( ColumnChartsParent.DEFAULTS.style, this.opts.style);


		// 标题信息
		if (opts.title) {
			this.title = this.publicFn.extendObj( ColumnChartsParent.DEFAULTS.title, this.opts.title);
		}else{
			this.title.isShow = false;
		}


	}






/*	return ColumnChartsParent;
})
*/



module.exports = ColumnChartsParent;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {



var ChartsParent = __webpack_require__(0);

/*
define(['chartsParent'], function(ChartsParent){
*/
	function LineChartsParent() {
		
	}

	var linepproto = LineChartsParent.prototype = new ChartsParent;



	// 进行第一次计算
	linepproto.firstCalculate = function(){
		this.paddingLR = 20 ;  // 设定左右留白区域
		this.isShowOriginal = true;  // 当前是否为初始图形

		var series = this.series;

		// 初始化series[i]全部为isShow = true
		this.initializationIsShowData(series);

		// 备份series中data
		this.dataBackUp();


		this.bindColor(series);

	}

	/*
	// 计算相关的比例
	linepproto.countBl = function(){
		
		var csYOneLen = this.opts.style.csYOneLen || 0;  // 纵坐标每个间距的值，由用户控制

		var arr = this.series;

		var maxNum = this.maxNum = this.publicFn.getMaxNum(arr);  // 数据中的最大值
		var minNum = this.minNum = this.publicFn.getMinNum(arr);


		var yCopies = this.cs.yCopies = 3; // 设置默认将y轴分为3分

		// 计算y轴刻度最小的值并把它转换为整数
		var csYMin = Math.floor(minNum*0.8); 

		var n2 = csYMin.toString().length;
		
		if (n2 > 1) {
			var n3 = Math.floor(csYMin/10);
			csYMin = this.cs.csYMin = parseInt(n3.toString() + '0')
		}else{
			this.cs.csYMin = csYMin;
		}

		var diff = Math.floor(maxNum/0.9 - csYMin); // 差值
		if (csYOneLen) {
			yCopies = Math.ceil(diff/csYOneLen); // 把展示的数据等分为几份
		}else{                              // 将数据的
			var n5 = Math.ceil(diff/yCopies).toString();
			if (parseInt(n5) > 5) {
				n5 = n5.slice(0, n5.length - 1) + '0';
				csYOneLen = parseInt(n5)  + 10;
			}else{
				csYOneLen = parseInt(n5)  + 5;
			}
		}
		
		var diff = yCopies*csYOneLen;  // 最终的跨度
		
		this.bl = this.cs.csHeight/diff;  // 比例
		this.cs.csYOneLen = csYOneLen;

	}*/

	// 计算相关的比例
	linepproto.countBl = function(){
		
		var csYOneLen = this.opts.style.csYOneLen || 1;  // 纵坐标每个间距的值，由用户控制

		var arr = this.series;

		var maxNum = this.maxNum = this.publicFn.getMaxNum(arr);  // 数据中的最大值



		var yCopies = 0;  // 设置默认将y轴分为3分

		// 计算y轴刻度最小的值直接从0开始算
		var csYMin = this.cs.csYMin = 0; 

		var diff = Math.floor(maxNum/0.9 - csYMin);  // 差值

		if (diff < 5) {

			diff = maxNum/0.9 - csYMin;
			var n1 = diff/5;
			var n2 = n1.toString();

			var i = 0;
			var maxI = 0;
			while(i >= 0){
				if (n2.charAt(2+i) !== '0' ) {
					break;
				}

				i++;
			}
			var divisor = 1;
			while(i >= 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			var n3 = n1*divisor;
			if (n3 < 1.4) {
				csYOneLen = 1/divisor;
			}else if(n3 < 2.5){
				csYOneLen = 2/divisor;
			}else if(n3 < 7.5){
				csYOneLen = 5/divisor;
			}else{
				csYOneLen = 10/divisor;
			}


		}else{

			var n1 = Math.ceil(diff/5);  // 将差值除以5，取整
			var n2 = n1.toString().length;  // 取得n1整数位的长度

			var i = n2 -1;
			var divisor = 1;
			while(i > 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			if (divisor === 1) {
				diff +=1;  // 当数值过小时，扩大差值
			}
				var n3 = n1/divisor;
				if (n3 < 1.4) {
					csYOneLen = 1*divisor;
				}else if(n3 < 2.5){
					csYOneLen = 2*divisor;
				}else if(n3 < 7.5){
					csYOneLen = 5*divisor;
				}else{
					csYOneLen = 10*divisor;
				}
			
		}

		yCopies = Math.ceil(diff/csYOneLen);

		
		var diff = yCopies*csYOneLen;  // 最终的跨度


		this.cs.yCopies = yCopies; 
		this.bl = this.cs.csHeight/diff;  // 比例
		this.cs.csYOneLen = csYOneLen;

		setYAxis.call(this);
		function setYAxis(){
			var yAxis = this.yAxis = []; 

			for(var j = 0; j <= yCopies; j++ ){

				var y = csYMin + csYOneLen*(yCopies*1000000-j*1000000)/1000000;	

				yAxis.push(y);			
			}

			
		}

	}



	linepproto.drawContent = function(){

		
		this.drawCS();
		this.drawGraph();

		// 存储鼠标移到x轴后所显示点的信息
		this.saveXDotsPsInfo();

	}


	linepproto.drawGraph = function(){

		var series = this.series;
		var ctx = this.ctx;
		var opts = this.opts;

		var csLeft = this.cs.csLeft ;
		var csTop = this.cs.csTop ;
		var csWidth = this.cs.csWidth;
		var csHeight = this.cs.csHeight;

		var bl = this.bl;
		var csYMin = this.cs.csYMin;
		var csXOneLen = this.cs.csXOneLen;

		// 生成数据图
		for(var i = 0, len = series.length; i < len; i++){
			var color = series[i].color || colors[i];   // 注意传入的color应该Wie一个数组
			draw.call(this, series[i]);		
		}

		


		/**
		 * 绘制曲线和阴影
		 * @param  {[type]} dataAll   对象{name:'邮件营销',data:[ 192, 201, 194, 290, 430, 310, 320] }
		 * @param  {[type]} color  颜色，为一个数组
		 */
		function draw( dataAll){

			
			

			var data = dataAll.data;
			// 将颜色和线条内容进行绑定

			ctx.beginPath();
			ctx.lineWidth = 1;  // 线条宽度
			ctx.strokeStyle = dataAll.color[0];

			//判断填充颜色是否为透明色
			if (opts.style.fillHyaline && opts.style.fillHyaline === true) {
				ctx.fillStyle= dataAll.color[1] || dataAll.color[1];
			}else{
				ctx.fillStyle= dataAll.color[0];
			}
			

			dataAll.dotsPst = [];  // 存储位置
			var tempX = 0;
			var tempY = 0;
			for(var i = 0, len = data.length; i < len; i++){

				var t = toCSNum(data[i], bl, csTop, csHeight, csYMin);
				var x = csLeft + csXOneLen*i;	
				
				dataAll.dotsPst.push([x, t]);

				
				if( i === 0){
					ctx.moveTo(x, t);
				}else{
					// ctx.lineTo(x, t);  // 终点
					ctx.arcTo(tempX,tempY,x,t,0);	
				}

				tempX = x;
				tempY = t;
				

				
				
			}

			ctx.arcTo(tempX,tempY,x,t,200);

			if (dataAll.isShow === false) { return; }

			ctx.stroke();

			//填充阴影,面积堆积图时进行填充
			if (this.opts.type === 'stackedAreaChart') {
				ctx.strokeStyle = 'rgba(0, 0, 0, 0)';
				ctx.lineTo(csLeft + csXOneLen*(i - 1), csTop + csHeight);
				ctx.lineTo(csLeft, csTop + csHeight);
				var t = toCSNum(data[0], bl, csTop, csHeight, csYMin);
				ctx.lineTo(csLeft, t);
				ctx.stroke();
				ctx.fill();
			}

			
		}

		// 根据数值、比例、坐标系top值、坐标系高度 ，返回所需的在canvas顶部值和高度值
		function toCSNum(data, bl, t, h, min){

			return t + (h - (data-min)*bl);
			
		}
	}



	// 绘制坐标
	linepproto.drawCS = function(){
		var opts = this.opts;
		var ctx = this.ctx;
		var series = this.series;

		var style = this.opts.style;

		this.cs = {};
		var csLeft = this.cs.csLeft = this.content.conLeft + this.opts.style.csYTxtLen;
		var csTop = this.cs.csTop = this.content.conTop + 10;
		var csWidth = this.cs.csWidth = this.content.conWidth - this.opts.style.csYTxtLen;
		var csHeight = this.cs.csHeight = this.content.conHeight - this.opts.style.csXTxtLen - 10;
		

		var csXLen = opts.xAxis.length - 1;  // 横坐标需要绘制多少个值,根据数组长度决定



		// 绘制坐标系,data为传进来的数据数组
		
		var style = this.opts.style;



		var csXOneLen = this.cs.csXOneLen = csWidth/csXLen;   // 每一个横坐标的间距

		var xAxis = this.xAxis;
		var series = this.series;

		this.countBl();


		// 横坐标横线绘制
		ctx.beginPath();

		ctx.strokeStyle = style.csXLineColor;
		ctx.lineWidth = style.csXlineWidth;  // 线条宽度

		ctx.moveTo(csLeft , csTop + csHeight);  // 起始点，移动画笔到(0, 0)
		ctx.lineTo(csLeft + csWidth,  csTop + csHeight);  
		ctx.stroke();


		// 判断是否绘制横坐标底部参数
		if(xAxis && this.showXAxis){

			ctx.fillStyle = style.csXfontColor;
			ctx.textAlign = "center";
			var bt = csTop + csHeight;  // 横坐标小短横起始纵位置
			var bb = csTop + csHeight + style.csXEveLen;  // 横坐标小短横结束纵位置 
			var ft = bb + style.csXfontTop;  // 横坐标字体的纵位置

			for(var i = 0; i < csXLen + 1; i++ ){
				ctx.moveTo(csLeft + csXOneLen*i, bt);  
				ctx.lineTo(csLeft + csXOneLen*i,  bb);

				ctx.font = style.csXfont;  // 字号 字体

				ctx.fillText(xAxis[i], csLeft + csXOneLen*i , ft);  // 内容 起始位置 
				
			}

			ctx.stroke();
		}



		
	 
		var bl = this.bl;
		var csYOneLen = this.cs.csYOneLen;
		var yCopies = this.cs.yCopies;
		var csYMin = this.cs.csYMin;
		var yAxis = this.yAxis;

		csYOneLenCanvas = bl*csYOneLen; // 跨度比例转换为canvas宽度


		// 绘制纵坐标
		ctx.strokeStyle = style.csYLineColor;
		ctx.fillStyle = style.csYfontColor;
		ctx.lineWidth = style.csYlineWidth;
		ctx.textAlign = "right";

		for(var j = 0; j <= yCopies; j++ ){

			ctx.moveTo(csLeft, csTop + csYOneLenCanvas*j);  
			ctx.lineTo( csLeft + csWidth,  csTop + csYOneLenCanvas*j);

			ctx.font = style.csYfont;  // 字号 字体

			ctx.fillText(yAxis[j], csLeft + style.csYfontLeft , csTop + csYOneLenCanvas*j + style.csYfontTop );  // 内容 起始位置 
			
		}
		ctx.stroke();



		
		// 横坐标横线绘制,最后绘制防止覆盖
		ctx.beginPath();

		ctx.strokeStyle = style.csXLineColor;
		ctx.lineWidth = style.csXlineWidth;  // 线条宽度

		ctx.moveTo(csLeft , csTop + csHeight);  // 起始点，移动画笔到(0, 0)
		ctx.lineTo(csLeft + csWidth,  csTop + csHeight);  
		ctx.stroke();

		

	}


	linepproto.drawMain = function(){

		var dom = this.opts.dom;


		/*
		var width = this.width = dom.width ;  // canvas宽
		var height = this.height = dom.height;  // canvas高
		*/


			
		var width = this.width = dom.width = dom.offsetWidth ;  // canvas宽
		var height = this.height = dom.height = dom.offsetHeight;  // canvas高


		this.ctx.clearRect( 0, 0, width, height);


		this.chartInit();

	}




	// 更新数据进行重绘
	linepproto.reflow = function(opts){

		this.series = opts.series || this.series;
		this.xAxis = opts.xAxis || this.xAxis;

		this.drawMain();


		return this;

	}


	/**
	 * 特效，绘制圆点
	 * @param  {Object} obj series数组中的某一个
	 */
	linepproto.drawMoveChange = function(obj){

		if (!obj) {return;}

		this.showOriginal();

		var r = 3;  // 圆点半径
		var borderWidth = 2;  // 圆点边框 
		var fillColor = '#fff';  // 边框颜色

		var ctx = this.ctx;
		
		ctx.lineWidth = borderWidth;
		ctx.fillStyle = fillColor;
		ctx.strokeStyle = obj.color[0];

		var dotsPst = obj.dotsPst;
		for (var i = 0, len = dotsPst.length; i < len; i++) {
			ctx.beginPath();
			ctx.arc(dotsPst[i][0],dotsPst[i][1],r,0,2*Math.PI);
			ctx.stroke();
			ctx.fill();
		}

	}

	// 鼠标移动到主体区域时,绘制虚线、竖线、相关信息
	linepproto.moveToContent = function(cx, cy){
		
		var cs = this.cs;		
		var ctx = this.ctx;	
		var _this = this;
		
		 
		// 进入坐标轴内区域
		if (cx > cs.csLeft && cx < cs.csLeft + cs.csWidth && cy > cs.csTop && cy < cs.csTop + cs.csHeight) {
			this.showOriginal();
			this.isShowOriginal = false;

			drawHorizontalLine();

			drawHorizontalDimension();

			

			// 判断鼠标目前在哪个区域内，以x轴为标准
			var csXOneLen = this.cs.csXOneLen;
			var thisI ;
			for (var i = 0; i < this.xAxis.length; i++) {

				if (cx > cs.csLeft + i*csXOneLen -csXOneLen/2 && cx <= cs.csLeft + i*csXOneLen+ csXOneLen/2) {
					thisI = i;
				}
			}
			
			if (typeof thisI !== 'undefined') {
				drawVerticalLine(thisI);
				drawDots(this.xDotsPst[thisI]);
				drawVerticalInfo(thisI);
			}
			






		// 移出坐标轴区域内
		}else{
			if (!this.isShowOriginal) {
				this.showOriginal();
				this.isShowOriginal = true;
			}
			
		}


		// 绘制横向虚线
		function drawHorizontalLine(){
			ctx.beginPath();
			ctx.strokeStyle = '#aaa';

			var sl = 5;  // 横线为虚线，每个小虚线的长度
			var len = Math.floor(cs.csWidth/sl/2);

			
			for (var i = 0; i < len; i++) {
				ctx.moveTo(cs.csLeft + sl*i*2, cy );
				ctx.lineTo(cs.csLeft + sl*i*2 + sl, cy);
			}

			if (cs.csLeft + sl*i*2  < cs.csLeft + cs.csWidth) {
				ctx.moveTo(cs.csLeft + sl*i*2, cy );
				ctx.lineTo(cs.csLeft + cs.csWidth, cy);
			}
			ctx.shadowBlur = 0;
			ctx.stroke();
		}



		// 绘制横向标注
		function drawHorizontalDimension(){

			var fontSize = 12;
			var span = 5;  // 数值左右留的边距
			var boxColor = '#6A7985';

			ctx.font = fontSize + 'px Arial'
			ctx.strokeStyle = boxColor;  // 字体背景颜色
			ctx.fillStyle = boxColor;  

			var fixLen = -1;  // 精确到截取的位数
			if (_this.cs.csYOneLen < 1) {
				fixLen = _this.cs.csYOneLen.toString().length -1;
			}else{
				fixLen = 1;
			}

			var trueValue = (cs.csYMin + (cs.csHeight-(cy - cs.csTop))/_this.bl).toFixed(fixLen);  // 侧边的数值
			var trueValueLen = ctx.measureText(trueValue).width ; // 侧边数值的宽度
			var boxW = trueValueLen + span*2;  // 侧边数值背景的宽度
			var boxH = fontSize + span;

			ctx.beginPath();
			ctx.rect(cs.csLeft - boxW , cy - boxH/2, boxW, boxH);
			ctx.stroke();
			ctx.fill();


			ctx.fillStyle = '#FFF';  // 字体颜色
			ctx.textAlign = 'end';
			ctx.fillText(trueValue, cs.csLeft - span, cy + fontSize/2);

		}



		// 绘制小圆点
		// dots应该为一个二维数组[[x1, y1, color1],[x2, y2, color2]]
		function drawDots(dotsPst){
			var r = 3;  // 圆点半径
			
			ctx.fillStyle = '#fff';
			for (var i = 0, len = dotsPst.length; i < len; i++) {
				
				ctx.strokeStyle = dotsPst[i][2];
				ctx.beginPath();
				ctx.arc(dotsPst[i][0],dotsPst[i][1],r,0,2*Math.PI);
				ctx.stroke();
				ctx.fill();
			}

		}


		// 绘制纵向直线
		function drawVerticalLine(i){
			var csXOneLen = _this.cs.csXOneLen;

			ctx.strokeStyle = '#ababab';
			ctx.beginPath();
			ctx.moveTo(cs.csLeft + csXOneLen*i, cs.csTop );
			ctx.lineTo(cs.csLeft + csXOneLen*i, cs.csTop + cs.csHeight);
			ctx.stroke();
		}





 
		// 绘制纵向直线上的标注
		function drawVerticalInfo(i){
			var fontSize = 12;
			var span = 5;  // 数值左右留的边距
			var boxColor = '#6A7985';


			var x = cs.csLeft + cs.csXOneLen*i;
			var y = cs.csTop + cs.csHeight + 6;

			ctx.beginPath();
			ctx.font = fontSize + 'px Arial'
			ctx.strokeStyle = boxColor;  // 字体背景颜色
			ctx.fillStyle = boxColor;  
			var text = _this.xAxis[i];  // 侧边的数值
			var textLen = ctx.measureText(text).width ; // 侧边数值的宽度
			var boxW = textLen + span*2;  // 侧边数值背景的宽度
			var boxH = fontSize + span;
			ctx.rect(x - boxW/2 , y, boxW, boxH);
			ctx.stroke();
			ctx.fill();

			ctx.fillStyle = '#FFF';  // 字体颜色
			ctx.textAlign = 'center';
			ctx.fillText(text, x, y + fontSize +span/2);
		}


	}


	// 存储x轴相对应个个点的信息
	linepproto.saveXDotsPsInfo = function(){

		var series = this.series;
		var xDotsPst = this.xDotsPst = [];
		for (var m = 0, len3 = this.xAxis.length; m < len3; m++) {
			xDotsPst[m] = [];
		}


		for (var i = 0, len = series.length; i < len; i++) {
			var dotsPst = series[i].dotsPst;
			var color = series[i].color[0];
			for (var j = 0, len2 = dotsPst.length; j < len2; j++) {
				xDotsPst[j][i] = dotsPst[j];
				xDotsPst[j][i].push(color);
			}
		}


	}


	linepproto.publicFn = {

		// data为三维数组，获得所有数据中的最大值
		getMaxNum: function (data){
			var max = 0;
			for(var i = 0, len = data.length; i < len; i++){
				for(var j = 0, lenj = data[i]['data'].length; j < lenj; j++){

					if (data[i]['data'][j] > max) {
						max = data[i]['data'][j];
					}
				}
			}

			return max;
		},


		// data为三维数组，获得所有数据中的最大值
		getMinNum: function (data){
			var min = 0;
			for(var i = 0, len = data.length; i < len; i++){

				if (data[i].isShow === false) {continue;}
				for(var j = 0, lenj = data[i]['data'].length; j < lenj; j++){
					if(i === 0 && j === 0){
						min = data[i]['data'][j];
					}

					if (data[i]['data'][j] < min) {
						min = data[i]['data'][j];
					}
				}
			}

			return min;
		},

		//  a为默认参数对象，b为传递进来的参数对象
		extendObj: function (a, b){  
			var str = JSON.stringify(a);
			var newobj = JSON.parse(str)
			for(key in b){
				if(newobj.hasOwnProperty(key)){
					newobj[key] = b[key];
				}else{
					newobj[key] = b[key];
					console.log('传入的参数'+key+'原本没有！');
				}
			}
			return newobj;
		},

		// 生成随机颜色，返回的数组，数组中有两个颜色值
		makeColor: function(){
			var arr = [];
			var a = Math.floor(Math.random()*256);
			var b = Math.floor(Math.random()*256);
			var c = Math.floor(Math.random()*256);
			var color1 = '#'+a.toString(16)+b.toString(16)+c.toString(16);
			arr.push(color1)
			var color2 = 'rgba('+a+', '+b+', '+c+', .5)';
			arr.push(color2);
			return arr;
		},


		// 将data恢复为原始数据
		restoreData: function(series){
			for (var i = 0, len = series.length; i < len ; i++) {
				if (series[i].isShow === false) {
					for (var j = 0, len2 = series[i]['data'].length; j < len2; j++) {
						series[i]['data'][j] = 0;
						
					}
				}else{
					series[i].data = JSON.parse(JSON.stringify(series[i].dataBackUp));
				}
				
			}
		},


	}




	// 初始化的参数变量
	LineChartsParent.DEFAULTS = {
		style: {
			csYTxtLen: 30,  // 设置y轴的数据预留宽度
			csXTxtLen: 40,

			csXLineColor :'#000',  // 坐标轴X的颜色
			csXlineWidth: 1,  // 坐标轴X线条的宽度
			csXEveLen: 5,  // 横坐标小短横的长度
			csXfont: "10px Arial",  // 横坐标参数的 字号 字体
			csXfontColor: "#000",  // 横坐标参数的颜色
			csXfontTop: 15,  // 横坐标参数距小短横的上位置

			csYLineColor: '#aaa',  // 坐标轴Y的颜色
			csYlineWidth: .2,  // 坐标轴Y线条的宽度
			csYfont: "12px Arial",  // 纵坐标参数的 字号 字体
			csYfontColor: "#000",  // 纵坐标参数的颜色
			csYfontLeft: -10,  // 纵坐标参数距当前长横的左位置
			csYfontTop: 5  // 纵坐标参数距当前长横的上位置
		}
		,
		title: { //图表绘制的区域
			text: '图表',
			color: '#000',
			font: '16px Arial',
			position: 'center',
			isShow: true
		},
	 /*	colorInfo: {
			font: '12px Arial',
			fontColor: '#000',
			boxWidth: 20,
			boxHeight: 20
		},*/
		

	}

	// 参数填充
	linepproto.extendOpts = function(){
		var opts = this.opts;
		var dom = opts.dom;
		this.xAxis = JSON.parse(JSON.stringify(opts.xAxis));
		this.series =JSON.parse(JSON.stringify(opts.series));


		this.showXAxis = true;
		if(opts.showXAxis != 'undefind'){
			
			this.showXAxis = opts.showXAxis;
		}


		// 坐标系样式信息
		if (!opts.style) {
			this.opts.style = {};
		}
		this.opts.style = this.publicFn.extendObj( LineChartsParent.DEFAULTS.style, this.opts.style);


		// 标题信息
		if (opts.title) {
			this.title = this.publicFn.extendObj( LineChartsParent.DEFAULTS.title, this.opts.title);
		}else{
			this.title.isShow = false;
		}


	}

/*	return LineChartsParent;
})*/





module.exports = LineChartsParent;




/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {


var ColumnChartsParent = __webpack_require__(1);

/*define(['columnChartsParent'], function(ColumnChartsParent){*/

	function ClusterColumnChart (opts){
		this.opts = opts;
		this.ctx = opts.dom.getContext("2d");
		this.ctx.translate(0.5,0.5);  // 使1px线变细
		this.init();
	}


	var proto = ClusterColumnChart.prototype = new ColumnChartsParent();

	proto.drawGraph = function(){
		var ctx = this.ctx;
		var cs = this.cs;
		var series = this.series;

		var csXOneLen = cs.csXOneLen;
		var csLeft = cs.csLeft;
		var csTop = cs.csTop;
		var csWidth = cs.csWidth;
		var csHeight = cs.csHeight;


		var sLen = 0;
		for (var i = 0; i < series.length; i++) {
			if(series[i].isShow === true){
				sLen++;
			}
		}


		var mScale = 0.2;  // 区块内柱形图的左右留白比例，也就是0.2*len 0.6*len 0.2*len
		var pScale = 0.05;  // 每个柱形的间隔比例

		 
		var columnW = csXOneLen*(1- mScale*2)
		var columnOneW = (columnW-csXOneLen*pScale*(sLen-1))/sLen;  // 单个柱子的宽度


		setColumnPst.call(this);
		fillRectColumn.call(this);


		// 存储柱形个个的坐标，宽高
		function setColumnPst(){
			
			var bl = this.bl;
			var csYMin = this.cs.csYMin;

			var ci = -1;
			for (var i = 0, len = series.length; i < len; i++) {
				var pst = series[i].columnPst = [];
				if(series[i].isShow === true){
					ci++;
				}
				for (var j = 0; j < series[i].data.length; j++) {

					
					var top = csTop + csHeight - (series[i].data[j] - csYMin)*bl;
					var left = csLeft + (j+mScale)*csXOneLen + (columnOneW+csXOneLen*pScale)*ci;
					var columnH = (series[i].data[j] - csYMin)*bl;


					var arr = [];
					arr.push(left, top, columnOneW, columnH, series[i].color[0]);
					pst.push(arr);

				}

			}

			
		}

		// 绘制柱形
		function fillRectColumn(){

			for (var i = 0; i < series.length; i++) {

				if (series[i].isShow === false) { continue;}

				ctx.beginPath();
				ctx.fillStyle = series[i].color[0];

				var pst = series[i].columnPst;
				
				for (var j = 0; j < pst.length; j++) {

					ctx.fillRect(pst[j][0], pst[j][1], pst[j][2], pst[j][3]);   // 减1的目的是不遮挡x轴
				}
			}
		}
	}



	proto.clickFlow = function(){
		

		this.ctx.clearRect(0, 0, this.width, this.height);
		// 将需要隐藏的柱形值设置为0
		this.publicFn.restoreData(this.series);

		this.drawTitle();
		this.drawCutLine();
		this.drawContent();
		this.saveOriginal();
	}



	// 鼠标移动到主体区域时,绘制灰色遮罩
	proto.moveToContent = function(cx, cy){
		var cs = this.cs;
		var _this = this;
		

		// 进入坐标系内
		if (cx > cs.csLeft && cx < cs.csLeft + cs.csWidth && cy > cs.csTop && cy < cs.csTop + cs.csHeight) {

			var x = cx - cs.csLeft;  // 转换为坐标系内x的值

			var csXOneLen = cs.csXOneLen;
			var thisI = -1;

			for (var i = 0, len = this.series[0].data.length; i < len; i++) {

				if (x > i*csXOneLen && x < (i+1)*csXOneLen) {
					thisI = i;

				}
			}

			if (thisI !== -1) {
				//if (moveI === thisI) {return;}
				//moveI = thisI;

				this.showOriginal();
				drawShadow(thisI);

				this.isShowOriginal = false;

			}
			
		}else{

			if (this.isShowOriginal === false) {
				this.showOriginal();
				this.isShowOriginal = true;
			}

		}

		function drawShadow(i){

					var ctx = _this.ctx;
					
					var csXOneLen = cs.csXOneLen;

					ctx.beginPath();
					ctx.fillStyle = 'rgba(100, 100, 100, .1)';  // 着重显示时的颜色
					ctx.fillRect(cs.csLeft + i*csXOneLen, cs.csTop, csXOneLen, cs.csHeight);
				}
	}



/*	return ClusterColumnChart;
});*/


module.exports = ClusterColumnChart;



/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var ColumnChartsParent = __webpack_require__(1);

/*
define(['columnChartsParent'], function(ColumnChartsParent){
*/

	function ClusterStackedColumnChart (opts){
		this.opts = opts;
		this.ctx = opts.dom.getContext("2d");
		this.ctx.translate(0.5,0.5);  // 使1px线变细
		
		this.init();
	}

	var proto = ClusterStackedColumnChart.prototype = new ColumnChartsParent();


/*	// 计算相关的比例
	proto.countBl = function(){
		
		var csYOneLen = this.opts.style.csYOneLen || 0;  // 纵坐标每个间距的值，由用户控制

		this.changeStructure()
		this.getExtremum();

		// 在这里获取的最大最小值
		var maxNum = this.maxNum;  // 数据中的最大值
		var minNum = this.minNum;


		var yCopies = this.cs.yCopies = 3; // 设置默认将y轴分为3分

		// 计算y轴刻度最小的值直接从0开始算
		var csYMin = this.cs.csYMin = 0; 

		var diff = Math.floor(maxNum/0.9 - csYMin); // 差值
		if (csYOneLen) {
			yCopies = Math.ceil(diff/csYOneLen); // 把展示的数据等分为几份
		}else{                              // 将数据的
			var n5 = Math.ceil(diff/yCopies).toString();
			if (parseInt(n5) > 5) {
				n5 = n5.slice(0, n5.length - 1) + '0';
				csYOneLen = parseInt(n5)  + 10;
			}else{
				csYOneLen = parseInt(n5)  + 5;
			}
		}
		
		var diff = yCopies*csYOneLen;  // 最终的跨度
		
		this.bl = this.cs.csHeight/diff;  // 比例
		this.cs.csYOneLen = csYOneLen;

	}  */


	// 计算相关的比例
	proto.countBl = function(){
		
		var csYOneLen = this.opts.style.csYOneLen || 1;  // 纵坐标每个间距的值，由用户控制

		this.changeStructure()
		this.getExtremum();




		var arr = this.series;

		var maxNum = this.maxNum ;  // 数据中的最大值



		var yCopies = 0;  // 设置默认将y轴分为3分

		// 计算y轴刻度最小的值直接从0开始算
		var csYMin = this.cs.csYMin = 0; 

		var diff = Math.floor(maxNum/0.9 - csYMin);  // 差值

		if (diff < 5) {

			diff = maxNum/0.9 - csYMin;
			var n1 = diff/5;
			var n2 = n1.toString();

			var i = 0;
			var maxI = 0;
			while(i >= 0){
				if (n2.charAt(2+i) !== '0' ) {
					break;
				}

				i++;
			}
			var divisor = 1;
			while(i >= 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			var n3 = n1*divisor;
			if (n3 < 1.4) {
				csYOneLen = 1/divisor;
			}else if(n3 < 2.5){
				csYOneLen = 2/divisor;
			}else if(n3 < 7.5){
				csYOneLen = 5/divisor;
			}else{
				csYOneLen = 10/divisor;
			}


		}else{

			var n1 = Math.ceil(diff/5);  // 将差值除以5，取整
			var n2 = n1.toString().length;  // 取得n1整数位的长度

			var i = n2 -1;
			var divisor = 1;
			while(i > 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			if (divisor === 1) {
				diff +=1;  // 当数值过小时，扩大差值
			}
				var n3 = n1/divisor;
				if (n3 < 1.4) {
					csYOneLen = 1*divisor;
				}else if(n3 < 2.5){
					csYOneLen = 2*divisor;
				}else if(n3 < 7.5){
					csYOneLen = 5*divisor;
				}else{
					csYOneLen = 10*divisor;
				}
			
		}

		yCopies = Math.ceil(diff/csYOneLen);

		
		var diff = yCopies*csYOneLen;  // 最终的跨度


		this.cs.yCopies = yCopies; 
		this.bl = this.cs.csHeight/diff;  // 比例
		this.cs.csYOneLen = csYOneLen;

		setYAxis.call(this);
		function setYAxis(){
			var yAxis = this.yAxis = []; 

			for(var j = 0; j <= yCopies; j++ ){

				var y = csYMin + csYOneLen*(yCopies*1000000-j*1000000)/1000000;	

				yAxis.push(y);			
			}

			
		}

		

	}



	// 构造新的数据结构传入this.newObj,原series不改变	 
	proto.changeStructure = function(){
		var newObj = {};
		var series = JSON.parse(JSON.stringify(this.series));

		for (var i = 0, len = series.length; i < len; i++) {

			var obj = {};
			var name = series[i].name;
			if(typeof series[i].stack === 'undefined'){
				newObj[name] = [];
				obj.name = series[i].name;
				obj.data = series[i].data;
				obj.color = series[i].color;
				newObj[name].push(obj);
			}else{

				var stack = series[i].stack;
				if (typeof newObj[stack] === 'undefined') {
					newObj[stack] = [];
				}

				obj.name = series[i].name;
				obj.data = series[i].data;
				obj.color = series[i].color;
				newObj[stack].push(obj);  
				
			}
		}

		this.newObj = newObj;

	}


	// 获取最大值以及最小值
	proto.getExtremum = function(){
		var obj = this.newObj;
		var max = -1;
		var min = -1;
		for (var key in obj) {
			if(obj.hasOwnProperty(key)){
				
				var arr = this.publicFn.spData2(obj[key]);

				var maxT = this.publicFn.getMaxNum(arr);
				var minT = this.publicFn.getMinNum(arr);

				if (maxT > max) {
					max = maxT;
				}

				if (min === -1 || minT < min) {
					min = minT
				}
			}
		}


		this.maxNum = max;
		this.minNum = min;

	}




	proto.drawGraph = function(){
		var ctx = this.ctx;
		var cs = this.cs;
		var series = this.series;

		var csXOneLen = cs.csXOneLen;
		var csLeft = cs.csLeft;
		var csTop = cs.csTop;
		var csWidth = cs.csWidth;
		var csHeight = cs.csHeight;

		var sLen = 0;
		var obj = this.newObj;
		for (var key in obj) {
			if(obj.hasOwnProperty(key)){
				

				var sp = this.publicFn.spData2(obj[key]);
				
				if(this.publicFn.getMaxNum(sp) > 0){
					sLen++;
				}


			}
		}



		var mScale = 0.2;  // 区块内柱形图的左右留白比例，也就是0.2*len 0.6*len 0.2*len
		var pScale = 0.05;  // 每个柱形的间隔比例

		 
		var columnW = csXOneLen*(1- mScale*2)
		var columnOneW = (columnW-csXOneLen*pScale*(sLen-1))/sLen;  // 单个柱子的宽度


		getColumnPst.call(this);
		matchPst.call(this);
		fillRectColumn.call(this);







		// 通过改变的数据newObj计算每个柱形的定位信息
		function getColumnPst() {

			var bl = this.bl;
			var csYMin = this.cs.csYMin;
			var obj = this.newObj;

			//var i = -1;
			var ci = -1;
			for (var key in obj) {
				if(obj.hasOwnProperty(key)){
					//i++;

					var sp = this.publicFn.spData2(obj[key]);
					
					if(this.publicFn.getMaxNum(sp) > 0){
						ci++;
					}
					for (var j = 0, len2 = obj[key].length; j < len2; j++) {

						
						var pst = obj[key][j].columnPst = [];

						for (var k = 0, len3 = obj[key][j].data.length; k < len3; k++) {
							
							var top = csTop + csHeight - (sp[j].data[k] - csYMin)*bl;
							var left = csLeft + (k+mScale)*csXOneLen + (columnOneW+csXOneLen*pScale)*ci;
							var columnH = (obj[key][j].data[k] - csYMin)*bl;

							var arr = [];
							arr.push(left, top, columnOneW, columnH, obj[key][j].color[0]);
							pst.push(arr);

						}
					}


				}
			}


			


		}

		// 将获得的个个定位数据进行匹配
		function matchPst(){
			var series = this.series;
			var obj = this.newObj; 
			var i = -1;
			for (var key in obj) {
				if(obj.hasOwnProperty(key)){
					i++;

					var sp = this.publicFn.spData2(obj[key]);
					for (var j = 0, len2 = obj[key].length; j < len2; j++) {

						var name = obj[key][j].name;
						
						var pst = obj[key][j].columnPst;

						series.map(function(value){
							if (value.name === name) {
								value.columnPst = pst;
							}
						});

					}


				}
			}


		}

		// 绘制柱形
		function fillRectColumn(){

			for (var i = 0; i < series.length; i++) {

				if (series[i].isShow === false) { continue;}

				ctx.beginPath();
				ctx.fillStyle = series[i].color[0];

				var pst = series[i].columnPst;
				
				for (var j = 0; j < pst.length; j++) {

					ctx.fillRect(pst[j][0], pst[j][1], pst[j][2], pst[j][3]);   // 减1的目的是不遮挡x轴
				}
			}
		}
	}



	proto.clickFlow = function(){
		

		this.ctx.clearRect(0, 0, this.width, this.height);

		// 将需要隐藏的柱形值设置为0
		this.publicFn.restoreData(this.series);


		this.drawTitle();
		this.drawCutLine();
		this.drawContent();
		this.saveOriginal();
	}



	// 鼠标移动到主体区域时,绘制灰色遮罩
	proto.moveToContent = function(cx, cy){
		var cs = this.cs;
		var _this = this;
		

		// 进入坐标系内
		if (cx > cs.csLeft && cx < cs.csLeft + cs.csWidth && cy > cs.csTop && cy < cs.csTop + cs.csHeight) {

			var x = cx - cs.csLeft;  // 转换为坐标系内x的值

			var csXOneLen = cs.csXOneLen;
			var thisI = -1;

			for (var i = 0, len = this.series[0].data.length; i < len; i++) {

				if (x > i*csXOneLen && x < (i+1)*csXOneLen) {
					thisI = i;

				}
			}

			if (thisI !== -1) {
				//if (moveI === thisI) {return;}
				//moveI = thisI;

				this.showOriginal();
				drawShadow(thisI);

				this.isShowOriginal = false;

			}
			
		}else{

			if (this.isShowOriginal === false) {
				this.showOriginal();
				this.isShowOriginal = true;
			}

		}

		function drawShadow(i){

					var ctx = _this.ctx;
					
					var csXOneLen = cs.csXOneLen;

					ctx.beginPath();
					ctx.fillStyle = 'rgba(100, 100, 100, .1)';  // 着重显示时的颜色
					ctx.fillRect(cs.csLeft + i*csXOneLen, cs.csTop, csXOneLen, cs.csHeight);
				}
	}


/*
	return ClusterStackedColumnChart;
});*/

module.exports = ClusterStackedColumnChart;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {



var LineChartsParent = __webpack_require__(2);

/*
define(['lineChartsParent'], function(LineChartsParent){
*/
	function LineChart(opts) {
		this.opts = opts;
		this.ctx = opts.dom.getContext("2d");
		this.ctx.translate(0.5,0.5);  // 使1px线变细
		this.init();
		
	}

	var lineproto = LineChart.prototype = new LineChartsParent;


	lineproto.clickFlow = function(){

		this.ctx.clearRect(0, 0, this.width, this.height);

		// 不显示的值设置为零
		this.publicFn.restoreData(this.series);


		this.drawTitle();
		this.drawCutLine();
		this.drawContent();
		this.saveOriginal();
	}



/*	return LineChart;

})
*/



module.exports = LineChart;




/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {



var ChartsParent = __webpack_require__(0);

/*
define(['chartsParent'], function(ChartsParent){
*/

	function PieChart(opts){
		this.opts = opts;

		this.init();
	}


	var pieProto = PieChart.prototype  = new ChartsParent;





	// 进行第一次计算
	pieProto.firstCalculate = function(){
		var _this = this;
		this.paddingLR = 20;  // 设定左右留白区域

		this.isShowColor = false;

		var series = this.series;

		// 初始化series[i]全部为isShow = true
		this.initializationIsShowData(series);

		// 备份series中data
		this.dataBackUp();


		// 从大到小排序数组
		// series.sort(function (a, b){ return b.data - a.data});

		// 填充数据颜色
		this.bindColor(series);


		this.publicFn.calculateScale(series);


	}



	pieProto.drawContent = function(){
		var _this = this;
		var ctx = this.ctx;
		var series = this.series;

		var conWidth = this.content.conWidth;
		var conHeight = this.content.conHeight;
		var conTop = this.content.conTop;
		var conLeft = this.content.conLeft;

		this.pie = {};
		// 绘制的中心值
		var centerL = this.pie.centerL =  Math.floor(conLeft + conWidth/2);
		var centerT = this.pie.centerT =Math.floor(conTop + conHeight/2);


		init();

		function init(){
			drawSectorAll();
			drawSectorInfo();
		}

		

		// 绘制扇形
		function drawSectorAll(){
			// 计算半径
			var radius =  _this.opts.radius || 0.9;
			var r = (conWidth < conHeight ? conWidth*radius : conHeight*radius)/2;
			_this.pie.r = r;
			if(r < 0) return;
			ctx.save()
			// 位移到圆心，方便绘制
			ctx.translate(centerL, centerT);

			for (var i = 0; i < series.length; i++) {
				drawSector(r, series[i].startAngle, series[i].startAngle + series[i].scale, series[i].color[0])
			}

			ctx.restore();


			/**
			 * 绘制扇形
			 * @param  {number} r 半径
			 * @param  {number} a 比例
			 * @param  {number} b [description]
			 * @return {[type]}   [description]
			 */
			function drawSector(r, a, b,color){
				ctx.fillStyle = color;
				ctx.beginPath();
				// 移动到圆心
				ctx.moveTo(0, 0);
				// 绘制圆弧
				ctx.arc(0, 0, r, Math.PI*2*a, Math.PI*2*b);
				// 闭合路径
				ctx.closePath(Math.PI*2*a, Math.PI*2*b);
				ctx.fill();



			}

		}

		// 绘制扇形的信息
		function drawSectorInfo(){
			var r = _this.pie.r;
			var sl = 10;  // 标注斜横长度
			var hl = 5;  // 标注短横长度

			var centerL = _this.pie.centerL;
			var centerT = _this.pie.centerT;


			var allLen = r + sl;

			for (var i = 0; i < series.length; i++) {	

				if (series[i].isShow === false) { continue;}
				
				var angle = (series[i].startAngle + series[i].scale/2)*2*Math.PI;
				var sinL = allLen*Math.sin(angle);
				var cosL = allLen*Math.cos(angle);
				var rsl = r*Math.sin(angle);
				var rcl = r*Math.cos(angle);

				ctx.beginPath();
				ctx.strokeStyle = series[i].color[0];
				ctx.fillStyle = '#000';
				
				
				ctx.moveTo(centerL + rcl, centerT + rsl);
				ctx.lineTo(centerL + cosL, centerT + sinL);
				if (cosL >= 0) {
					ctx.lineTo(centerL + cosL + hl, centerT + sinL);
					ctx.textAlign = 'start';
					ctx.fillText(series[i].cutName, centerL + cosL + hl + 3, centerT + sinL + _this.cutLine.fontSize/2);
				}else{
					ctx.lineTo(centerL + cosL - hl, centerT + sinL);
					ctx.textAlign = 'end';
					ctx.fillText(series[i].cutName, centerL + cosL + hl - 13, centerT + sinL + _this.cutLine.fontSize/2);
				}
				ctx.stroke();

			}
		}


	}

	pieProto.drawMain = function(){
		var dom = this.opts.dom;
		var ctx = this.ctx;
			
		var width = this.width = dom.width = dom.offsetWidth ;  // canvas宽
		var height = this.height = dom.height = dom.offsetHeight;  // canvas高


		this.ctx.clearRect( 0, 0, width, height);

		this.chartInit();
		

	}



	pieProto.clickFlow = function(){

		this.ctx.clearRect(0, 0, this.width, this.height);


		// 不显示的值设置为零
		this.publicFn.restoreData(this.series);
		this.publicFn.calculateScale(this.series);


		this.drawTitle();
		this.drawCutLine();
		this.drawContent();
		this.saveOriginal();

	}



	// 更新数据进行重绘
	pieProto.reflow = function(opts){

		this.series = opts.series || this.series;
		this.drawMain();
		return this;

	}




	/**
	 * 绘制颜色的改变
	 * @param  {Object} obj series数组中的某一个
	 */
	pieProto.drawMoveChange = function(obj){
		var ctx = this.ctx;

		if (!obj) {return;}

		this.showOriginal();

		ctx.save()
		// 位移到圆心，方便绘制
		ctx.translate(this.pie.centerL, this.pie.centerT);

		ctx.fillStyle = 'rgba(255, 255, 255, .3)';
		ctx.beginPath();
		// 移动到圆心
		ctx.moveTo(0, 0);
		// 绘制圆弧
		
		ctx.arc(0, 0, this.pie.r, Math.PI*2*obj.startAngle, Math.PI*2*obj.startAngle + Math.PI*2*obj.scale);
		// 闭合路径
		ctx.closePath(Math.PI*2*obj.startAngle, Math.PI*2*obj.startAngle + Math.PI*2*obj.startAngle);
		ctx.fill();

		ctx.restore();

	}


	// 当鼠标移动到主体区域，进行动态绘制
	pieProto.moveToContent = function(cx, cy){
		var r = this.pie.r;
		var series = this.series;

		var centerL = this.pie.centerL;
		var centerT = this.pie.centerT;

		var diffX = cx - centerL;
		var diffY = cy - centerT;

		


		// 进入饼图区域
		if(Math.pow(diffX, 2) + Math.pow(diffY, 2) < Math.pow(r, 2)){
			var a = Math.atan(diffY/diffX)/Math.PI/2; // 比值
			if (diffX < 0 && diffY > 0) {
				a = 0.5 + a;
			}else if(diffX < 0 && diffY < 0){
				a = a + 0.5;
			}else if(diffX > 0 && diffY < 0){
				a = a + 1;
			}

			

			for (var i = 0, len = series.length; i < len; i++) {
				var moveI ;
				if(a > series[i].startAngle){					
					moveI = i;
				}
			}

			
			if (!this.isShowColor ) {   // this.isShowColor定义在 firstCalculate 中
				
				this.drawMoveChange(series[moveI]);
				this.isShowColor = true;
			}else if(this.lastI !== moveI){
				this.showOriginal();
				this.drawMoveChange(series[moveI]);
				this.isShowColor = true;
			}
			this.lastI = moveI;
		}else{
			this.isShowColor = false;
			this.showOriginal();
		}
	}




	pieProto.publicFn = {


		//  a为默认参数对象，b为传递进来的参数对象
		extendObj: function (a, b){ 

			var str = JSON.stringify(a);
			var newobj = JSON.parse(str)
			for(key in b){
				if(newobj.hasOwnProperty(key)){
					newobj[key] = b[key];
				}else{
					newobj[key] = b[key];
					console.log('传入的参数'+key+'原本没有！');
				}
			}

			return newobj;
		},

		restoreData: function(series){

			for (var i = 0, len = series.length; i < len ; i++) {
				if (series[i].isShow === false) {
					series[i].data = 0;
				}else{
					series[i].data = series[i].dataBackUp;
				}
				
			}

		},


		// 计算比例和
		calculateScale: function(series){

			var sumNum = 0;
			var sumScale = 0;

			for (var i = 0; i < series.length; i++) {
				sumNum += series[i].data;
			}

			for (var i = 0, scale = 0; i < series.length; i++) {
				scale = series[i].data/sumNum;
				series[i].startAngle = sumScale;
				series[i].scale = scale;  //百分比例
				sumScale += scale;
				
			}

		}

	}


	// 初始化的参数变量
	PieChart.DEFAULTS = {

		title: { //图表绘制的区域
			text: '图表-饼图',
			color: '#000',
			font: '16px Arial',
			position: 'center',
			isShow: true
		}

	}

	// 参数填充
	pieProto.extendOpts = function(){
		var opts = this.opts;
		this.ctx = opts.dom.getContext("2d");
		this.ctx.translate(0.5, 0.5);

		this.series =JSON.parse(JSON.stringify(opts.series));


		// 标题信息
		if (opts.title) {
			this.title = this.publicFn.extendObj( PieChart.DEFAULTS.title, this.opts.title);
		}else{
			this.title.isShow = false;
		}


	}

/*	return PieChart;
})*/




module.exports = PieChart;



/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {


var ColumnChartsParent = __webpack_require__(1);

/*
define(['columnChartsParent'], function(ColumnChartsParent){
*/
	function SimpleColumnChart (opts){
		this.opts = opts;
		this.ctx = opts.dom.getContext("2d");
		this.ctx.translate(0.5,0.5);  // 使1px线变细
		this.init();
	}



	var proto = SimpleColumnChart.prototype = new ColumnChartsParent();


	proto.chartInit = function(){


		this.drawTitle();

		// 不需要绘制图例
		// this.drawCutLine();

		this.confirmContentRegion();

		this.drawContent();

	}

	// 确定主体的绘制区域
	proto.confirmContentRegion = function(){

		// 	确定需要给坐标预留的空间

		var title = this.title;
		var width = this.width;
		var height = this.height;

		var titleNeedH = this.titleNeedH;

		var paddingLR = this.paddingLR;

		var content = this.content = {};
	 	content.conTop = titleNeedH;
	 	content.conHeight = height - titleNeedH;
	 	content.conLeft = paddingLR;
	 	content.conWidth = width -paddingLR*2;


	}





	// 绘制柱形
	proto.drawGraph = function(){
		var ctx = this.ctx;
		var cs = this.cs;
		var series = this.series;

		var csXOneLen = cs.csXOneLen;
		var csLeft = cs.csLeft;
		var csTop = cs.csTop;
		var csWidth = cs.csWidth;
		var csHeight = cs.csHeight;


		var mScale = 0.2;  // 区块内柱形图的左右留白比例

		 

		var columnW = csXOneLen*(1- mScale*2);  // 单个柱子的宽度

		var data = series[0].data;  // 二维数组传入时应该只有的一个数组，这里就默认为[0].data
		var csYMin = this.cs.csYMin;
		ctx.fillStyle = series[0].color[0];
		for (var i = 0, len = data.length; i < len; i++) {

			var columnH = (data[i] - csYMin)*this.bl;

			ctx.beginPath();

			ctx.fillRect(csLeft + (i+mScale)*csXOneLen, csTop + csHeight - columnH, columnW, columnH - 1);   // 减1的目的是不遮挡x轴

			
		}




	}



// 没有图例，重写该方法添加监听鼠标移动的特效动效
proto.addListenDynamic = function(){
	var _this = this;
	var dom = this.opts.dom;
	var width = this.width;
	var height = this.height;


	var isShowDots = false;  // 是否显示了小圆点


	this.saveOriginal();

	window.addEventListener('mousemove', function(e){
		
		var gbc = dom.getBoundingClientRect();
		var top = gbc.top;
		var left = gbc.left;
		
		var x = e.clientX;
		var y = e.clientY;
		
		// 判断是否在canvas的区域内
		if (x > left && x < left + width && y > top && y < top + height) {

			// 鼠标在canvas上的相对坐标
			var cx = x - left;
			var cy = y - top;

			var series = _this.series;

				// 进入中间主体区域
				if (cx > _this.content.conLeft && cx < _this.content.conLeft + _this.content.conWidth){
					
					_this.moveToContent(cx, cy);
					
				}else {

					if (_this.isShowOriginal === false) {
						
						_this.showOriginal();
						_this.isShowOriginal = true;
					}
				}



			/**
			 * 遍历判断是否在区域内
			 * @param {Number} start 起始值
			 * @param {Number} len   当前条件下的一排的个数
			 */
			function analyzingConditionsAreaX(start, len){
				var moveI ;
				var isMovein = false;  // 是否移入了图标
				for (var i = start; i < len; i++) {
					if ( cx > series[i].cutLinePst.boxLeftA && cx < series[i].cutLinePst.textLeftA + series[i].ctxLen) {									
						isMovein = true;
						moveI = i;
					}
				}
				if (isMovein) {
					
					if (!series[moveI].isShow) {return}

					if (isShowDots) { return;}
					
					_this.drawMoveChange(series[moveI]);
					isShowDots = true;
					_this.opts.dom.style.cursor = 'pointer';
				}else{
											
					if (!isShowDots) {return;}						
					isShowDots = false;
					isMovein = false;
					_this.showOriginal();
					
					_this.opts.dom.style.cursor = 'default';
				}
			}

			/**
			 * @param {Number} len      当前条件下的竖排的个数
			 * @param {Number} fontSize 图例的字体大小
			 */
			function analyzingConditionsAreaY(len, fontSize){
				var moveI ;
				var isMovein = false;  // 是否移入了图标
				for (var i = 0; i < len; i++) {
					if ( cy > series[i].cutLinePst.textTopA -  fontSize&& cy < series[i].cutLinePst.textTopA ) {	
						if (cx > series[i].cutLinePst.boxLeftA && cx < series[i].cutLinePst.textLeftA +series[i].ctxLen) {
							isMovein = true;
							moveI = i;
						}								
					}
				}
				if (isMovein) {
					if (!series[moveI].isShow) {return}  // 图标显示为灰色的就不画该圆点了

					if (isShowDots) { return;}
					
					_this.drawMoveChange(series[moveI]);
					isShowDots = true;
					_this.opts.dom.style.cursor = 'pointer';
				}else{
						

					if (_this.isShowOriginal === false) {
						_this.showOriginal();
					}

					if (!isShowDots) {return;}
											
					isShowDots = false;
					isMovein = false;
					
					_this.opts.dom.style.cursor = 'default';



				}
			}

		}
		
	})

}




// 鼠标移动到主体区域时,绘制灰色遮罩
proto.moveToContent = function(cx, cy){
	var cs = this.cs;
	var _this = this;
	

	// 进入坐标系内
	if (cx > cs.csLeft && cx < cs.csLeft + cs.csWidth && cy > cs.csTop && cy < cs.csTop + cs.csHeight) {

		var x = cx - cs.csLeft;  // 转换为坐标系内x的值

		var csXOneLen = cs.csXOneLen;
		var thisI = -1;

		for (var i = 0, len = this.series[0].data.length; i < len; i++) {

			if (x > i*csXOneLen && x < (i+1)*csXOneLen) {
				thisI = i;

			}
		}

		if (thisI !== -1) {
			//if (moveI === thisI) {return;}
			//moveI = thisI;

			this.showOriginal();
			drawShadow(thisI);

			this.isShowOriginal = false;

		}
		
	}else{

		if (this.isShowOriginal === false) {
			this.showOriginal();
			this.isShowOriginal = true;
		}

	}

	function drawShadow(i){

				var ctx = _this.ctx;
				
				var csXOneLen = cs.csXOneLen;

				ctx.beginPath();
				ctx.fillStyle = 'rgba(100, 100, 100, .1)';  // 着重显示时的颜色
				ctx.fillRect(cs.csLeft + i*csXOneLen, cs.csTop, csXOneLen, cs.csHeight);
			}
}




	// 没有图例就没有点击事件，这个函数的目的是覆盖本来需要执行的函数
	proto.addListenClick = function(){}



/*	return SimpleColumnChart;
		
});*/


module.exports = SimpleColumnChart;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {




var ColumnChartsParent = __webpack_require__(1);

/*
define(['columnChartsParent'], function(ColumnChartsParent){
*/


function SimpleStackedColumnChart(opts){
	this.opts = opts;
	this.ctx = opts.dom.getContext("2d");
	this.ctx.translate(0.5,0.5);  // 使1px线变细
	this.init();
}

var proto = SimpleStackedColumnChart.prototype = new ColumnChartsParent();





/*// 计算相关的比例
proto.countBl = function(){
	
	var csYOneLen = this.opts.style.csYOneLen || 0;  // 纵坐标每个间距的值，由用户控制

	var arr = this.publicFn.spData2(this.series);

	var maxNum = this.maxNum = this.publicFn.getMaxNum(arr);  // 数据中的最大值
	var minNum = this.minNum = this.publicFn.getMinNum(arr);


	var yCopies = this.cs.yCopies = 3; // 设置默认将y轴分为3分

	// 计算y轴刻度最小的值直接从0开始算
	var csYMin = this.cs.csYMin = 0; 

	var diff = Math.floor(maxNum/0.9 - csYMin); // 差值
	if (csYOneLen) {
		yCopies = Math.ceil(diff/csYOneLen); // 把展示的数据等分为几份
	}else{                              // 将数据的
		var n5 = Math.ceil(diff/yCopies).toString();
		if (parseInt(n5) > 5) {
			n5 = n5.slice(0, n5.length - 1) + '0';
			csYOneLen = parseInt(n5)  + 10;
		}else{
			csYOneLen = parseInt(n5)  + 5;
		}
	}
	
	var diff = yCopies*csYOneLen;  // 最终的跨度
	
	this.bl = this.cs.csHeight/diff;  // 比例
	this.cs.csYOneLen = csYOneLen;

}*/

// 计算相关的比例
proto.countBl = function(){
	
	var csYOneLen = this.opts.style.csYOneLen || 1;  // 纵坐标每个间距的值，由用户控制


	var arr = this.publicFn.spData2(this.series);

	var maxNum = this.maxNum = this.publicFn.getMaxNum(arr);  // 数据中的最大值



	var yCopies = 0;  // 设置默认将y轴分为3分

	// 计算y轴刻度最小的值直接从0开始算
	var csYMin = this.cs.csYMin = 0; 

	var diff = Math.floor(maxNum/0.9 - csYMin);  // 差值

	if (diff < 5) {

		diff = maxNum/0.9 - csYMin;
		var n1 = diff/5;
		var n2 = n1.toString();

		var i = 0;
		var maxI = 0;
		while(i >= 0){
			if (n2.charAt(2+i) !== '0' ) {
				break;
			}

			i++;
		}
		var divisor = 1;
		while(i >= 0){
			divisor = divisor*10;  // 计算n1要除的整数
			i--;
		}
		var n3 = n1*divisor;
		if (n3 < 1.4) {
			csYOneLen = 1/divisor;
		}else if(n3 < 2.5){
			csYOneLen = 2/divisor;
		}else if(n3 < 7.5){
			csYOneLen = 5/divisor;
		}else{
			csYOneLen = 10/divisor;
		}


	}else{

		var n1 = Math.ceil(diff/5);  // 将差值除以5，取整
		var n2 = n1.toString().length;  // 取得n1整数位的长度

		var i = n2 -1;
		var divisor = 1;
		while(i > 0){
			divisor = divisor*10;  // 计算n1要除的整数
			i--;
		}
		if (divisor === 1) {
			diff +=1;  // 当数值过小时，扩大差值
		}
			var n3 = n1/divisor;
			if (n3 < 1.4) {
				csYOneLen = 1*divisor;
			}else if(n3 < 2.5){
				csYOneLen = 2*divisor;
			}else if(n3 < 7.5){
				csYOneLen = 5*divisor;
			}else{
				csYOneLen = 10*divisor;
			}
		
	}

	yCopies = Math.ceil(diff/csYOneLen);

	
	var diff = yCopies*csYOneLen;  // 最终的跨度


	this.cs.yCopies = yCopies; 
	this.bl = this.cs.csHeight/diff;  // 比例
	this.cs.csYOneLen = csYOneLen;

	setYAxis.call(this);
	function setYAxis(){
		var yAxis = this.yAxis = []; 

		for(var j = 0; j <= yCopies; j++ ){

			var y = csYMin + csYOneLen*(yCopies*1000000-j*1000000)/1000000;	

			yAxis.push(y);			
		}

		
	}

	

}




// 绘制柱形
proto.drawGraph = function(){

	
	var ctx = this.ctx;
	var cs = this.cs;
	var series = this.series;

	var csXOneLen = cs.csXOneLen;
	var csLeft = cs.csLeft;
	var csTop = cs.csTop;
	var csWidth = cs.csWidth;
	var csHeight = cs.csHeight;


	var mScale = 0.2;  // 区块内柱形图的左右留白比例

	 

	var columnW = csXOneLen*(1- mScale*2);  // 单个柱子的宽度


	setColumnPst.call(this);
	fillRectColumn.call(this);


	// 存储柱形个个的坐标，宽高
	function setColumnPst(){
		var sumHeightArr = this.publicFn.spData2(series);  // 累加后数组
		var bl = this.bl;
		var csYMin = this.cs.csYMin;

		for (var i = 0, len = series.length; i < len; i++) {
			var pst = series[i].columnPst = [];
			for (var j = 0; j < series[i].data.length; j++) {

				
				var top = csTop + csHeight - (sumHeightArr[i].data[j] - csYMin)*bl;
				var columnH = series[i].data[j]*bl;

				


				var arr = [];
				arr.push(csLeft + (j+mScale)*csXOneLen, top, columnW, columnH, series[i].color[0]);
				pst.push(arr);

			}

		}

		
	}

	// 绘制柱形
	function fillRectColumn(){

		for (var i = 0; i < series.length; i++) {

			if (series[i].isShow === false) { continue;}

			ctx.beginPath();
			ctx.fillStyle = series[i].color[0];

			var pst = series[i].columnPst;
			
			for (var j = 0; j < pst.length; j++) {

				ctx.fillRect(pst[j][0], pst[j][1], pst[j][2], pst[j][3]);   // 减1的目的是不遮挡x轴
			}
		}
	}



}




// 鼠标移动到主体区域时,绘制灰色遮罩
proto.moveToContent = function(cx, cy){
	var cs = this.cs;
	var _this = this;
	

	// 进入坐标系内
	if (cx > cs.csLeft && cx < cs.csLeft + cs.csWidth && cy > cs.csTop && cy < cs.csTop + cs.csHeight) {

		var x = cx - cs.csLeft;  // 转换为坐标系内x的值

		var csXOneLen = cs.csXOneLen;
		var thisI = -1;

		for (var i = 0, len = this.series[0].data.length; i < len; i++) {

			if (x > i*csXOneLen && x < (i+1)*csXOneLen) {
				thisI = i;

			}
		}

		if (thisI !== -1) {
			//if (moveI === thisI) {return;}
			//moveI = thisI;

			this.showOriginal();
			drawShadow(thisI);

			this.isShowOriginal = false;

		}
		
	}else{

		if (this.isShowOriginal === false) {
			this.showOriginal();
			this.isShowOriginal = true;
		}

	}

	function drawShadow(i){

				var ctx = _this.ctx;
				
				var csXOneLen = cs.csXOneLen;

				ctx.beginPath();
				ctx.fillStyle = 'rgba(100, 100, 100, .1)';  // 着重显示时的颜色
				ctx.fillRect(cs.csLeft + i*csXOneLen, cs.csTop, csXOneLen, cs.csHeight);
			}
}






proto.clickFlow = function(){
	

	this.ctx.clearRect(0, 0, this.width, this.height);

	// 将需要隐藏的柱形值设置为0
	this.publicFn.restoreData(this.series);


	this.drawTitle();
	this.drawCutLine();
	this.drawContent();
	this.saveOriginal();
}





proto.publicFn = {
	// data为三维数组，获得所有数据中的最大值
	getMaxNum: function (data){
		var max = 0;
		for(var i = 0, len = data.length; i < len; i++){
			for(var j = 0, lenj = data[i]['data'].length; j < lenj; j++){

				if (data[i]['data'][j] > max) {
					max = data[i]['data'][j];
				}
			}
		}

		return max;
	},
	getMinNum: function(series){
		var endData = series[series.length - 1].data;
		var min = -1;
		for (var i = 0; i < endData.length; i++) {

			if (i === 0) {
				min = endData[i]
			}
		 	if (endData[i] < min) {
		 		min = endData[i];
		 	}
		} 
		return min;
	},

	//  a为默认参数对象，b为传递进来的参数对象
	extendObj: function (a, b){  
		var str = JSON.stringify(a);
		var newobj = JSON.parse(str)
		for(key in b){
			if(newobj.hasOwnProperty(key)){
				newobj[key] = b[key];
			}else{
				newobj[key] = b[key];
				console.log('传入的参数'+key+'原本没有！');
			}
		}
		return newobj;
	},

	// 生成随机颜色，返回的数组，数组中有两个颜色值
	makeColor: function(){
		var arr = [];
		var a = Math.floor(Math.random()*256);
		var b = Math.floor(Math.random()*256);
		var c = Math.floor(Math.random()*256);
		var color1 = '#'+a.toString(16)+b.toString(16)+c.toString(16);
		arr.push(color1)
		var color2 = 'rgba('+a+', '+b+', '+c+', .5)';
		arr.push(color2);
		return arr;
	},

	// 数据累加
	spData2: function(series){
		var cloneData = JSON.parse(JSON.stringify(series));  // 克隆一个对象 
		var len = cloneData.length;
		var len2 = cloneData[0].data.length;  // 应保证 每一行的数据长度相同，这里默认为数据格式正确

		
		for (var i = 0, len = series.length - 1; i < len; i++) {

			for (var j = 0; j < len2; j++) {

				cloneData[i+1].data[j] = cloneData[i].data[j] + cloneData[i+1].data[j];
			} 

		}
		return cloneData;
	},

	// 将data恢复为原始数据
	restoreData: function(series){
		
		for (var i = 0, len = series.length; i < len ; i++) {
			if (series[i].isShow === false) {
				for (var j = 0, len2 = series[i]['data'].length; j < len2; j++) {
					series[i]['data'][j] = 0;
					
				}
			}else{
				series[i].data = JSON.parse(JSON.stringify(series[i].dataBackUp));
			}
			
		}
		
	},

	/**
	 * 计算起始的top值
	 * @param  {Number} outTop   外部的top
	 * @param  {Number} csHeight 坐标的高度
	 * @param  {Number} bl       比例
	 * @param  {Number} h        柱形需要占据的高度
	 * @return {Number}          起始的top值
	 */
	countStartTop: function(outTop, csHeight, bl, h){
		return outTop + csHeight - h*bl;
	}


}





/*return SimpleStackedColumnChart;
})
*/


module.exports = SimpleStackedColumnChart;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {





var ChartsParent = __webpack_require__(0);
var LineChartsParent = __webpack_require__(2);

/*
define(['chartsParent', 'lineChartsParent'], function(ChartsParent, LineChartsParent){
*/
	function StackedAreaChart(opts) {
		this.opts = opts;
		this.ctx = opts.dom.getContext("2d");
		this.ctx.translate(0.5,0.5);  // 使1px线变细
		this.init();
		
	}
	
	var stackproto = StackedAreaChart.prototype = new LineChartsParent;


	// 计算相关的比例
	stackproto.countBl = function(){
		
		var csYOneLen = this.opts.style.csYOneLen || 1;  // 纵坐标每个间距的值，由用户控制

		var arr = this.series;

		var maxNum = this.maxNum = this.publicFn.getMaxNum(arr);  // 数据中的最大值



		var yCopies = 0;  // 设置默认将y轴分为3分

		// 计算y轴刻度最小的值直接从0开始算
		var csYMin = this.cs.csYMin = 0; 

		var diff = Math.floor(maxNum/0.9 - csYMin);  // 差值

		if (diff < 5) {

			diff = maxNum/0.9 - csYMin;
			var n1 = diff/5;
			var n2 = n1.toString();

			var i = 0;
			var maxI = 0;
			while(i >= 0){
				if (n2.charAt(2+i) !== '0' ) {
					break;
				}

				i++;
			}
			var divisor = 1;
			while(i >= 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			var n3 = n1*divisor;
			if (n3 < 1.4) {
				csYOneLen = 1/divisor;
			}else if(n3 < 2.5){
				csYOneLen = 2/divisor;
			}else if(n3 < 7.5){
				csYOneLen = 5/divisor;
			}else{
				csYOneLen = 10/divisor;
			}


		}else{

			var n1 = Math.ceil(diff/5);  // 将差值除以5，取整
			var n2 = n1.toString().length;  // 取得n1整数位的长度

			var i = n2 -1;
			var divisor = 1;
			while(i > 0){
				divisor = divisor*10;  // 计算n1要除的整数
				i--;
			}
			if (divisor === 1) {
				diff +=1;  // 当数值过小时，扩大差值
			}
				var n3 = n1/divisor;
				if (n3 < 1.4) {
					csYOneLen = 1*divisor;
				}else if(n3 < 2.5){
					csYOneLen = 2*divisor;
				}else if(n3 < 7.5){
					csYOneLen = 5*divisor;
				}else{
					csYOneLen = 10*divisor;
				}
			
		}

		yCopies = Math.ceil(diff/csYOneLen);

		
		var diff = yCopies*csYOneLen;  // 最终的跨度


		this.cs.yCopies = yCopies; 
		this.bl = this.cs.csHeight/diff;  // 比例
		this.cs.csYOneLen = csYOneLen;

		setYAxis.call(this);
		function setYAxis(){
			var yAxis = this.yAxis = []; 

			for(var j = 0; j <= yCopies; j++ ){

				var y = csYMin + csYOneLen*(yCopies*1000000-j*1000000)/1000000;	

				yAxis.push(y);			
			}

			
		}

		

	}



	// 进行第一次计算
	stackproto.firstCalculate = function(){

		this.paddingLR = 20 ;  // 设定左右留白区域

		var series = this.series;

		// 初始化series[i]全部为isShow = true
		// this.initializationIsShowData(series);

		// 备份series中data
		this.dataBackUp();



		this.bindColor(series);	


		// 适配处理数据
		this.dataAdapter();

	}




	// 数组格式适配，数组排序为从大到小排列
	stackproto.dataAdapter = function(){
		var series = this.series;

		// 计算和并排序数组
		// stackproto.publicFn.sumData(series);
		// stackproto.publicFn.sortData(series);
		this.series = stackproto.publicFn.spData(this.series);

		
	}


	stackproto.clickFlow = function(){

		this.ctx.clearRect(0, 0, this.width, this.height);

		// 重新计算
		stackproto.publicFn.restoreData(this.series);
		this.series = stackproto.publicFn.spData(this.series);




		this.drawTitle();
		this.drawCutLine();
		this.drawContent();
		this.saveOriginal();
	}




	stackproto.publicFn = {

		// data为三维数组，获得所有数据中的最大值
		getMaxNum: function (data){
			var max = 0;
			for(var i = 0, len = data.length; i < len; i++){

				for(var j = 0, lenj = data[i]['data'].length; j < lenj; j++){

					if (data[i]['data'][j] > max) {
						max = data[i]['data'][j];
					}
				}
			}

			return max;
		},


		// data为三维数组，获得所有数据中的最大值
		getMinNum: function (data){
			var min = 0;
			for(var i = 0, len = data.length; i < len; i++){

				if (data[i].isShow === false) {continue;}
				for(var j = 0, lenj = data[i]['data'].length; j < lenj; j++){
					if(i === 0 && j === 0){
						min = data[i]['data'][j];
					}

					if (data[i]['data'][j] < min) {
						min = data[i]['data'][j];
					}
				}
			}

			return min;
		},

		//  a为默认参数对象，b为传递进来的参数对象
		extendObj: function (a, b){  
			var str = JSON.stringify(a);
			var newobj = JSON.parse(str)
			for(key in b){
				if(newobj.hasOwnProperty(key)){
					newobj[key] = b[key];
				}else{
					newobj[key] = b[key];
					console.log('传入的参数'+key+'原本没有！');
				}
			}
			return newobj;
		},


		// 将data恢复为原始数据
		restoreData: function(series){
			
			for (var i = 0, len = series.length; i < len ; i++) {
				if (series[i].isShow === false) {
					for (var j = 0, len2 = series[i]['data'].length; j < len2; j++) {
						series[i]['data'][j] = 0;
						
					}
				}else{
					series[i].data = JSON.parse(JSON.stringify(series[i].dataBackUp));
				}
				
			}
			
		},


		/** 将数据转化为叠加模式
		 * @param  {Array} series形如 [{
		            name:'邮件营销',
		            data:[ 194, 290, 430, 310, 320, 342, 370]
		        },
		        {
		            name:'联盟广告',
		            data:[ 191, 234, 290, 330, 310, 250, 300]
		        }]
		 * @return {Array}  返回数据格式与传入格式相同，但data值为累计叠加
		 */
		spData: function (series){
			var newData = JSON.parse(JSON.stringify(series));  // 克隆一个对象 

			var arr = [];

			for (var len = series.length - 1, i = len; i > 0; i--) {
				if (i == len) {
					arr = series[len]['data'];
				}
				var arrPre = series[i-1]['data'];
				var sArr = [];

				for (var j = 0, lenj = arr.length; j < lenj; j++) {
				 	sArr.push(arr[j]+arrPre[j]);
				} 
				newData[i-1]['data'] = sArr;
				arr = sArr; 
			}
			return newData;

		},
		/**
		 * 计算数据的和
		 * @param  {Arrage} series 
		 * @return {Arrage} 无会改变当前数组的值
		 */
		sumData: function(series){
			for (var i = 0, len = series.length; i < len; i++) {
				var sum = series[i].data.reduce(function(total, num){
					return total + num;
				});
				series[i].sum = sum;
			}

		},
		/**
		 * 排序数组
		 * @param  {Arrage} series 
		 * @return {Arrage} 无返回值在原数组上进行排序
		 */
		sortData: function(series){

			series.sort(function(a, b){
				return a.sum - b.sum;
			});

		}

	}

/*	return StackedAreaChart;
});*/



module.exports = StackedAreaChart;




/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {


var StackedAreaChart = __webpack_require__(9);
var PieChart = __webpack_require__(6);
var LineChart = __webpack_require__(5);
var SimpleColumnChart = __webpack_require__(7);
var SimpleStackedColumnChart = __webpack_require__(8);
var ClusterColumnChart = __webpack_require__(3);
var ClusterStackedColumnChart = __webpack_require__(4);


/*
define(['stackedAreaChart', 'pieChart', 'lineChart', 'simpleColumnChart', 'simpleStackedColumnChart', 'clusterColumnChart', 'clusterStackedColumnChart'], function(StackedAreaChart, PieChart, LineChart, SimpleColumnChart, SimpleStackedColumnChart, ClusterColumnChart, ClusterStackedColumnChart){
*/
	window.schart = function(opts){
		var type = opts.type; 
		var obj ;

		switch(type){
			case 'stackedAreaChart': 
				obj = new StackedAreaChart(opts);
				break;
			case 'pieChart':
				obj = new PieChart(opts);
				break;
			case 'lineChart':
				obj = new LineChart(opts);
				break;
			case 'simpleColumnChart':
				obj = new SimpleColumnChart(opts);
				break;
			case 'simpleStackedColumnChart':
				obj = new SimpleStackedColumnChart(opts);
				break;
			case 'clusterColumnChart': 
				obj = new ClusterColumnChart(opts);
				break;
			case 'clusterStackedColumnChart':
				obj = new ClusterStackedColumnChart(opts);
				break;
			default: 
				throw new Error('传入参数type，有误'); 
		}

		return obj;
	}

	

/*	return window.schart;
})
*/




/***/ })
/******/ ]);